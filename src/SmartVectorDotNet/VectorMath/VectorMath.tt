<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var vectorMathMatcher = new Regex(
    @"\[VectorMath(?:Attribute)?\]\s*" +
    @"(?<accessibility>public|internal|private)\s+static\s+partial\s+Vector\s*<\s*T\s*>\s+(?<method>\w+)\s*<\s*T\s*>\s*\((?<args>.+)\)\s*" + 
    @"where\s+T\s*:\s*unmanaged\s*;");

var methodDefinitions = new Dictionary<string, MethodDef[]>();
foreach(var vectorMathPath in Directory.GetFiles(Host.ResolvePath("."), "*.cs"))
{
    if(vectorMathPath.EndsWith(".g.cs"))
    {
        continue;
    }
    var vectorMathSource = File.ReadAllText(vectorMathPath);
    var matcheds = vectorMathMatcher.Matches(
        vectorMathSource);
    var methods = matcheds.Cast<Match>().Select(match => new MethodDef(match)).ToArray();
    methodDefinitions.Add(
        Path.GetFileName(vectorMathPath),
        methods);
}
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace SmartVectorDotNet;
using H = InternalHelpers;


<#  foreach(var kv in methodDefinitions) { #>
<#      var filename = kv.Key; #>
<#      var methods = kv.Value; #>
// <#=filename#>
partial class VectorMath
{
<#      foreach(var method in methods) { #>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    <#=method.Accessibility#> static partial Vector<T> <#=method.Name#><T>(<#=method.ArgumentDecl#>)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
<#          GenerateMethodArgumentReinterpretation(method, "double"); #>
            return H.Reinterpret<double, T>(<#=method.SpecializedCall#>);
        }
        if(typeof(T) == typeof(float))
        {
<#          GenerateMethodArgumentReinterpretation(method, "float"); #>
            return H.Reinterpret<float, T>(<#=method.SpecializedCall#>);
        }
        throw new NotSupportedException();
    }

<#      } #>
}

<#  } #>
<#+
public class MethodDef
{
    private static readonly Regex _ArgumentMatcher = new (@"Vector\s*<\s*T\s*>\s+(?<argname>\w+)");

    public string Accessibility { get; }
    public string Name { get; }
    public string[] Arguments { get; }

    public string ArgumentDecl => string.Join(", ", Arguments.Select(a => $"Vector<T> {a}"));

    public string SpecializedCall => $"{Name}({string.Join(", ", Arguments.Select(a => $"{a}_"))})";

    public MethodDef(Match match)
    {
        Accessibility = match.Groups["accessibility"].Value;
        Name = match.Groups["method"].Value;
        Arguments = _ArgumentMatcher
            .Matches(match.Groups["args"].Value)
            .Cast<Match>()
            .Select(m => m.Groups["argname"].Value)
            .ToArray();
    }
}

public void GenerateMethodArgumentReinterpretation(MethodDef method, string type)
{
    foreach(var arg in method.Arguments) { #>
            ref readonly var <#=arg#>_ = ref H.Reinterpret<T, <#=type#>>(<#=arg#>);
<#+
    }
}
#>