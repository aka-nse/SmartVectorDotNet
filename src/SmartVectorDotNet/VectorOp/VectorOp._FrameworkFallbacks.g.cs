// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using NVector = System.Numerics.Vector;
using static SmartVectorDotNet.InternalHelpers;

namespace SmartVectorDotNet;

partial class VectorOp
{

    public static partial Vector<float > Ceiling(Vector<float > value)
    {
#if NET6_0_OR_GREATER
        return NVector.Ceiling(value);
#else
        switch(Vector<float>.Count)
        {
        case 2:
            return CreateVector(stackalloc []{
                ScalarMath.Ceiling(value[0]),
                ScalarMath.Ceiling(value[1]),
            });
        case 4:
            return CreateVector(stackalloc []{
                ScalarMath.Ceiling(value[0]),
                ScalarMath.Ceiling(value[1]),
                ScalarMath.Ceiling(value[2]),
                ScalarMath.Ceiling(value[3]),
            });
        case 8:
            return CreateVector(stackalloc []{
                ScalarMath.Ceiling(value[0]),
                ScalarMath.Ceiling(value[1]),
                ScalarMath.Ceiling(value[2]),
                ScalarMath.Ceiling(value[3]),
                ScalarMath.Ceiling(value[4]),
                ScalarMath.Ceiling(value[5]),
                ScalarMath.Ceiling(value[6]),
                ScalarMath.Ceiling(value[7]),
            });
        default:
            {
                var buffer = (stackalloc float[Vector<float>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = ScalarMath.Ceiling(value[i]);
                }
                return Unsafe.As<float, Vector<float>>(ref buffer[0]);
            }
        }
#endif
    }


    public static partial Vector<double> Ceiling(Vector<double> value)
    {
#if NET6_0_OR_GREATER
        return NVector.Ceiling(value);
#else
        switch(Vector<double>.Count)
        {
        case 1:
            return CreateVector(stackalloc []{
                ScalarMath.Ceiling(value[0]),
            });
        case 2:
            return CreateVector(stackalloc []{
                ScalarMath.Ceiling(value[0]),
                ScalarMath.Ceiling(value[1]),
            });
        case 4:
            return CreateVector(stackalloc []{
                ScalarMath.Ceiling(value[0]),
                ScalarMath.Ceiling(value[1]),
                ScalarMath.Ceiling(value[2]),
                ScalarMath.Ceiling(value[3]),
            });
        default:
            {
                var buffer = (stackalloc double[Vector<double>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = ScalarMath.Ceiling(value[i]);
                }
                return Unsafe.As<double, Vector<double>>(ref buffer[0]);
            }
        }
#endif
    }


    public static partial Vector<float > Floor  (Vector<float > value)
    {
#if NET6_0_OR_GREATER
        return NVector.Floor  (value);
#else
        switch(Vector<float>.Count)
        {
        case 2:
            return CreateVector(stackalloc []{
                ScalarMath.Floor  (value[0]),
                ScalarMath.Floor  (value[1]),
            });
        case 4:
            return CreateVector(stackalloc []{
                ScalarMath.Floor  (value[0]),
                ScalarMath.Floor  (value[1]),
                ScalarMath.Floor  (value[2]),
                ScalarMath.Floor  (value[3]),
            });
        case 8:
            return CreateVector(stackalloc []{
                ScalarMath.Floor  (value[0]),
                ScalarMath.Floor  (value[1]),
                ScalarMath.Floor  (value[2]),
                ScalarMath.Floor  (value[3]),
                ScalarMath.Floor  (value[4]),
                ScalarMath.Floor  (value[5]),
                ScalarMath.Floor  (value[6]),
                ScalarMath.Floor  (value[7]),
            });
        default:
            {
                var buffer = (stackalloc float[Vector<float>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = ScalarMath.Floor  (value[i]);
                }
                return Unsafe.As<float, Vector<float>>(ref buffer[0]);
            }
        }
#endif
    }


    public static partial Vector<double> Floor  (Vector<double> value)
    {
#if NET6_0_OR_GREATER
        return NVector.Floor  (value);
#else
        switch(Vector<double>.Count)
        {
        case 1:
            return CreateVector(stackalloc []{
                ScalarMath.Floor  (value[0]),
            });
        case 2:
            return CreateVector(stackalloc []{
                ScalarMath.Floor  (value[0]),
                ScalarMath.Floor  (value[1]),
            });
        case 4:
            return CreateVector(stackalloc []{
                ScalarMath.Floor  (value[0]),
                ScalarMath.Floor  (value[1]),
                ScalarMath.Floor  (value[2]),
                ScalarMath.Floor  (value[3]),
            });
        default:
            {
                var buffer = (stackalloc double[Vector<double>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = ScalarMath.Floor  (value[i]);
                }
                return Unsafe.As<double, Vector<double>>(ref buffer[0]);
            }
        }
#endif
    }

}
