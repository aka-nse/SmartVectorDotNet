// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.CompilerServices;
#if NETCOREAPP3_0_OR_GREATER
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
#endif
using System.Text;
using NVector = System.Numerics.Vector;
using H = SmartVectorDotNet.InternalHelpers;

#pragma warning disable CS0162

namespace SmartVectorDotNet;

file class BitMasks
{
    public static readonly Vector<uint> _31 = new(31);
    public static readonly Vector<ulong> _63 = new(63);
}


partial class VectorOp
{
    #region ShiftLeft

    #region

    public static partial Vector<byte> ShiftLeft(Vector<byte> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<byte> ShiftLeftFallback(Vector<byte> value, int shiftCount)
    {
        switch(Vector<byte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] << (shiftCount & 7)),
                (byte)(value[1] << (shiftCount & 7)),
                (byte)(value[2] << (shiftCount & 7)),
                (byte)(value[3] << (shiftCount & 7)),
                (byte)(value[4] << (shiftCount & 7)),
                (byte)(value[5] << (shiftCount & 7)),
                (byte)(value[6] << (shiftCount & 7)),
                (byte)(value[7] << (shiftCount & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] << (shiftCount & 7)),
                (byte)(value[1] << (shiftCount & 7)),
                (byte)(value[2] << (shiftCount & 7)),
                (byte)(value[3] << (shiftCount & 7)),
                (byte)(value[4] << (shiftCount & 7)),
                (byte)(value[5] << (shiftCount & 7)),
                (byte)(value[6] << (shiftCount & 7)),
                (byte)(value[7] << (shiftCount & 7)),
                (byte)(value[8] << (shiftCount & 7)),
                (byte)(value[9] << (shiftCount & 7)),
                (byte)(value[10] << (shiftCount & 7)),
                (byte)(value[11] << (shiftCount & 7)),
                (byte)(value[12] << (shiftCount & 7)),
                (byte)(value[13] << (shiftCount & 7)),
                (byte)(value[14] << (shiftCount & 7)),
                (byte)(value[15] << (shiftCount & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] << (shiftCount & 7)),
                (byte)(value[1] << (shiftCount & 7)),
                (byte)(value[2] << (shiftCount & 7)),
                (byte)(value[3] << (shiftCount & 7)),
                (byte)(value[4] << (shiftCount & 7)),
                (byte)(value[5] << (shiftCount & 7)),
                (byte)(value[6] << (shiftCount & 7)),
                (byte)(value[7] << (shiftCount & 7)),
                (byte)(value[8] << (shiftCount & 7)),
                (byte)(value[9] << (shiftCount & 7)),
                (byte)(value[10] << (shiftCount & 7)),
                (byte)(value[11] << (shiftCount & 7)),
                (byte)(value[12] << (shiftCount & 7)),
                (byte)(value[13] << (shiftCount & 7)),
                (byte)(value[14] << (shiftCount & 7)),
                (byte)(value[15] << (shiftCount & 7)),
                (byte)(value[16] << (shiftCount & 7)),
                (byte)(value[17] << (shiftCount & 7)),
                (byte)(value[18] << (shiftCount & 7)),
                (byte)(value[19] << (shiftCount & 7)),
                (byte)(value[20] << (shiftCount & 7)),
                (byte)(value[21] << (shiftCount & 7)),
                (byte)(value[22] << (shiftCount & 7)),
                (byte)(value[23] << (shiftCount & 7)),
                (byte)(value[24] << (shiftCount & 7)),
                (byte)(value[25] << (shiftCount & 7)),
                (byte)(value[26] << (shiftCount & 7)),
                (byte)(value[27] << (shiftCount & 7)),
                (byte)(value[28] << (shiftCount & 7)),
                (byte)(value[29] << (shiftCount & 7)),
                (byte)(value[30] << (shiftCount & 7)),
                (byte)(value[31] << (shiftCount & 7)),
            });
        default:
            {
                var buffer = (stackalloc byte[Vector<byte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (byte)(value[i] << (shiftCount & 7));
                }
                return Unsafe.As<byte, Vector<byte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<ushort> ShiftLeft(Vector<ushort> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<ushort>.Count == Vector256<ushort>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 15)));
        }
        if(Vector<ushort>.Count == Vector128<ushort>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 15)));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<ushort> ShiftLeftFallback(Vector<ushort> value, int shiftCount)
    {
        switch(Vector<ushort>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] << (shiftCount & 15)),
                (ushort)(value[1] << (shiftCount & 15)),
                (ushort)(value[2] << (shiftCount & 15)),
                (ushort)(value[3] << (shiftCount & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] << (shiftCount & 15)),
                (ushort)(value[1] << (shiftCount & 15)),
                (ushort)(value[2] << (shiftCount & 15)),
                (ushort)(value[3] << (shiftCount & 15)),
                (ushort)(value[4] << (shiftCount & 15)),
                (ushort)(value[5] << (shiftCount & 15)),
                (ushort)(value[6] << (shiftCount & 15)),
                (ushort)(value[7] << (shiftCount & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] << (shiftCount & 15)),
                (ushort)(value[1] << (shiftCount & 15)),
                (ushort)(value[2] << (shiftCount & 15)),
                (ushort)(value[3] << (shiftCount & 15)),
                (ushort)(value[4] << (shiftCount & 15)),
                (ushort)(value[5] << (shiftCount & 15)),
                (ushort)(value[6] << (shiftCount & 15)),
                (ushort)(value[7] << (shiftCount & 15)),
                (ushort)(value[8] << (shiftCount & 15)),
                (ushort)(value[9] << (shiftCount & 15)),
                (ushort)(value[10] << (shiftCount & 15)),
                (ushort)(value[11] << (shiftCount & 15)),
                (ushort)(value[12] << (shiftCount & 15)),
                (ushort)(value[13] << (shiftCount & 15)),
                (ushort)(value[14] << (shiftCount & 15)),
                (ushort)(value[15] << (shiftCount & 15)),
            });
        default:
            {
                var buffer = (stackalloc ushort[Vector<ushort>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (ushort)(value[i] << (shiftCount & 15));
                }
                return Unsafe.As<ushort, Vector<ushort>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<uint> ShiftLeft(Vector<uint> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<uint>.Count == Vector256<uint>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 31)));
        }
        if(Vector<uint>.Count == Vector128<uint>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 31)));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<uint> ShiftLeftFallback(Vector<uint> value, int shiftCount)
    {
        switch(Vector<uint>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] << (shiftCount & 31)),
                (uint)(value[1] << (shiftCount & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] << (shiftCount & 31)),
                (uint)(value[1] << (shiftCount & 31)),
                (uint)(value[2] << (shiftCount & 31)),
                (uint)(value[3] << (shiftCount & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] << (shiftCount & 31)),
                (uint)(value[1] << (shiftCount & 31)),
                (uint)(value[2] << (shiftCount & 31)),
                (uint)(value[3] << (shiftCount & 31)),
                (uint)(value[4] << (shiftCount & 31)),
                (uint)(value[5] << (shiftCount & 31)),
                (uint)(value[6] << (shiftCount & 31)),
                (uint)(value[7] << (shiftCount & 31)),
            });
        default:
            {
                var buffer = (stackalloc uint[Vector<uint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (uint)(value[i] << (shiftCount & 31));
                }
                return Unsafe.As<uint, Vector<uint>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<ulong> ShiftLeft(Vector<ulong> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<ulong>.Count == Vector256<ulong>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 63)));
        }
        if(Vector<ulong>.Count == Vector128<ulong>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 63)));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<ulong> ShiftLeftFallback(Vector<ulong> value, int shiftCount)
    {
        switch(Vector<ulong>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] << (shiftCount & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] << (shiftCount & 63)),
                (ulong)(value[1] << (shiftCount & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] << (shiftCount & 63)),
                (ulong)(value[1] << (shiftCount & 63)),
                (ulong)(value[2] << (shiftCount & 63)),
                (ulong)(value[3] << (shiftCount & 63)),
            });
        default:
            {
                var buffer = (stackalloc ulong[Vector<ulong>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (ulong)(value[i] << (shiftCount & 63));
                }
                return Unsafe.As<ulong, Vector<ulong>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nuint> ShiftLeft(Vector<nuint> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<nuint> ShiftLeftFallback(Vector<nuint> value, int shiftCount)
    {
        switch(Vector<nuint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[2] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[3] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[2] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[3] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[4] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[5] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[6] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[7] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nuint[Vector<nuint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nuint)(value[i] << (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1)));
                }
                return Unsafe.As<nuint, Vector<nuint>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<sbyte> ShiftLeft(Vector<sbyte> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<sbyte> ShiftLeftFallback(Vector<sbyte> value, int shiftCount)
    {
        switch(Vector<sbyte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] << (shiftCount & 7)),
                (sbyte)(value[1] << (shiftCount & 7)),
                (sbyte)(value[2] << (shiftCount & 7)),
                (sbyte)(value[3] << (shiftCount & 7)),
                (sbyte)(value[4] << (shiftCount & 7)),
                (sbyte)(value[5] << (shiftCount & 7)),
                (sbyte)(value[6] << (shiftCount & 7)),
                (sbyte)(value[7] << (shiftCount & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] << (shiftCount & 7)),
                (sbyte)(value[1] << (shiftCount & 7)),
                (sbyte)(value[2] << (shiftCount & 7)),
                (sbyte)(value[3] << (shiftCount & 7)),
                (sbyte)(value[4] << (shiftCount & 7)),
                (sbyte)(value[5] << (shiftCount & 7)),
                (sbyte)(value[6] << (shiftCount & 7)),
                (sbyte)(value[7] << (shiftCount & 7)),
                (sbyte)(value[8] << (shiftCount & 7)),
                (sbyte)(value[9] << (shiftCount & 7)),
                (sbyte)(value[10] << (shiftCount & 7)),
                (sbyte)(value[11] << (shiftCount & 7)),
                (sbyte)(value[12] << (shiftCount & 7)),
                (sbyte)(value[13] << (shiftCount & 7)),
                (sbyte)(value[14] << (shiftCount & 7)),
                (sbyte)(value[15] << (shiftCount & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] << (shiftCount & 7)),
                (sbyte)(value[1] << (shiftCount & 7)),
                (sbyte)(value[2] << (shiftCount & 7)),
                (sbyte)(value[3] << (shiftCount & 7)),
                (sbyte)(value[4] << (shiftCount & 7)),
                (sbyte)(value[5] << (shiftCount & 7)),
                (sbyte)(value[6] << (shiftCount & 7)),
                (sbyte)(value[7] << (shiftCount & 7)),
                (sbyte)(value[8] << (shiftCount & 7)),
                (sbyte)(value[9] << (shiftCount & 7)),
                (sbyte)(value[10] << (shiftCount & 7)),
                (sbyte)(value[11] << (shiftCount & 7)),
                (sbyte)(value[12] << (shiftCount & 7)),
                (sbyte)(value[13] << (shiftCount & 7)),
                (sbyte)(value[14] << (shiftCount & 7)),
                (sbyte)(value[15] << (shiftCount & 7)),
                (sbyte)(value[16] << (shiftCount & 7)),
                (sbyte)(value[17] << (shiftCount & 7)),
                (sbyte)(value[18] << (shiftCount & 7)),
                (sbyte)(value[19] << (shiftCount & 7)),
                (sbyte)(value[20] << (shiftCount & 7)),
                (sbyte)(value[21] << (shiftCount & 7)),
                (sbyte)(value[22] << (shiftCount & 7)),
                (sbyte)(value[23] << (shiftCount & 7)),
                (sbyte)(value[24] << (shiftCount & 7)),
                (sbyte)(value[25] << (shiftCount & 7)),
                (sbyte)(value[26] << (shiftCount & 7)),
                (sbyte)(value[27] << (shiftCount & 7)),
                (sbyte)(value[28] << (shiftCount & 7)),
                (sbyte)(value[29] << (shiftCount & 7)),
                (sbyte)(value[30] << (shiftCount & 7)),
                (sbyte)(value[31] << (shiftCount & 7)),
            });
        default:
            {
                var buffer = (stackalloc sbyte[Vector<sbyte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (sbyte)(value[i] << (shiftCount & 7));
                }
                return Unsafe.As<sbyte, Vector<sbyte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<short> ShiftLeft(Vector<short> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<short>.Count == Vector256<short>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 15)));
        }
        if(Vector<short>.Count == Vector128<short>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 15)));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<short> ShiftLeftFallback(Vector<short> value, int shiftCount)
    {
        switch(Vector<short>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] << (shiftCount & 15)),
                (short)(value[1] << (shiftCount & 15)),
                (short)(value[2] << (shiftCount & 15)),
                (short)(value[3] << (shiftCount & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] << (shiftCount & 15)),
                (short)(value[1] << (shiftCount & 15)),
                (short)(value[2] << (shiftCount & 15)),
                (short)(value[3] << (shiftCount & 15)),
                (short)(value[4] << (shiftCount & 15)),
                (short)(value[5] << (shiftCount & 15)),
                (short)(value[6] << (shiftCount & 15)),
                (short)(value[7] << (shiftCount & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] << (shiftCount & 15)),
                (short)(value[1] << (shiftCount & 15)),
                (short)(value[2] << (shiftCount & 15)),
                (short)(value[3] << (shiftCount & 15)),
                (short)(value[4] << (shiftCount & 15)),
                (short)(value[5] << (shiftCount & 15)),
                (short)(value[6] << (shiftCount & 15)),
                (short)(value[7] << (shiftCount & 15)),
                (short)(value[8] << (shiftCount & 15)),
                (short)(value[9] << (shiftCount & 15)),
                (short)(value[10] << (shiftCount & 15)),
                (short)(value[11] << (shiftCount & 15)),
                (short)(value[12] << (shiftCount & 15)),
                (short)(value[13] << (shiftCount & 15)),
                (short)(value[14] << (shiftCount & 15)),
                (short)(value[15] << (shiftCount & 15)),
            });
        default:
            {
                var buffer = (stackalloc short[Vector<short>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (short)(value[i] << (shiftCount & 15));
                }
                return Unsafe.As<short, Vector<short>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<int> ShiftLeft(Vector<int> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<int>.Count == Vector256<int>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 31)));
        }
        if(Vector<int>.Count == Vector128<int>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 31)));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<int> ShiftLeftFallback(Vector<int> value, int shiftCount)
    {
        switch(Vector<int>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] << (shiftCount & 31)),
                (int)(value[1] << (shiftCount & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] << (shiftCount & 31)),
                (int)(value[1] << (shiftCount & 31)),
                (int)(value[2] << (shiftCount & 31)),
                (int)(value[3] << (shiftCount & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] << (shiftCount & 31)),
                (int)(value[1] << (shiftCount & 31)),
                (int)(value[2] << (shiftCount & 31)),
                (int)(value[3] << (shiftCount & 31)),
                (int)(value[4] << (shiftCount & 31)),
                (int)(value[5] << (shiftCount & 31)),
                (int)(value[6] << (shiftCount & 31)),
                (int)(value[7] << (shiftCount & 31)),
            });
        default:
            {
                var buffer = (stackalloc int[Vector<int>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (int)(value[i] << (shiftCount & 31));
                }
                return Unsafe.As<int, Vector<int>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<long> ShiftLeft(Vector<long> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<long>.Count == Vector256<long>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 63)));
        }
        if(Vector<long>.Count == Vector128<long>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & 63)));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<long> ShiftLeftFallback(Vector<long> value, int shiftCount)
    {
        switch(Vector<long>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] << (shiftCount & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] << (shiftCount & 63)),
                (long)(value[1] << (shiftCount & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] << (shiftCount & 63)),
                (long)(value[1] << (shiftCount & 63)),
                (long)(value[2] << (shiftCount & 63)),
                (long)(value[3] << (shiftCount & 63)),
            });
        default:
            {
                var buffer = (stackalloc long[Vector<long>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (long)(value[i] << (shiftCount & 63));
                }
                return Unsafe.As<long, Vector<long>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nint> ShiftLeft(Vector<nint> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<nint> ShiftLeftFallback(Vector<nint> value, int shiftCount)
    {
        switch(Vector<nint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[4] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[5] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[6] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[7] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nint[Vector<nint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nint)(value[i] << (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1)));
                }
                return Unsafe.As<nint, Vector<nint>>(ref buffer[0]);
            }
        }
    }

    #endregion

    #region

    public static partial Vector<byte> ShiftLeft(Vector<byte> value, Vector<byte> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<byte> ShiftLeftFallback(Vector<byte> value, Vector<byte> shiftCount)
    {
        switch(Vector<byte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] << ((int)shiftCount[0] & 7)),
                (byte)(value[1] << ((int)shiftCount[1] & 7)),
                (byte)(value[2] << ((int)shiftCount[2] & 7)),
                (byte)(value[3] << ((int)shiftCount[3] & 7)),
                (byte)(value[4] << ((int)shiftCount[4] & 7)),
                (byte)(value[5] << ((int)shiftCount[5] & 7)),
                (byte)(value[6] << ((int)shiftCount[6] & 7)),
                (byte)(value[7] << ((int)shiftCount[7] & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] << ((int)shiftCount[0] & 7)),
                (byte)(value[1] << ((int)shiftCount[1] & 7)),
                (byte)(value[2] << ((int)shiftCount[2] & 7)),
                (byte)(value[3] << ((int)shiftCount[3] & 7)),
                (byte)(value[4] << ((int)shiftCount[4] & 7)),
                (byte)(value[5] << ((int)shiftCount[5] & 7)),
                (byte)(value[6] << ((int)shiftCount[6] & 7)),
                (byte)(value[7] << ((int)shiftCount[7] & 7)),
                (byte)(value[8] << ((int)shiftCount[8] & 7)),
                (byte)(value[9] << ((int)shiftCount[9] & 7)),
                (byte)(value[10] << ((int)shiftCount[10] & 7)),
                (byte)(value[11] << ((int)shiftCount[11] & 7)),
                (byte)(value[12] << ((int)shiftCount[12] & 7)),
                (byte)(value[13] << ((int)shiftCount[13] & 7)),
                (byte)(value[14] << ((int)shiftCount[14] & 7)),
                (byte)(value[15] << ((int)shiftCount[15] & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] << ((int)shiftCount[0] & 7)),
                (byte)(value[1] << ((int)shiftCount[1] & 7)),
                (byte)(value[2] << ((int)shiftCount[2] & 7)),
                (byte)(value[3] << ((int)shiftCount[3] & 7)),
                (byte)(value[4] << ((int)shiftCount[4] & 7)),
                (byte)(value[5] << ((int)shiftCount[5] & 7)),
                (byte)(value[6] << ((int)shiftCount[6] & 7)),
                (byte)(value[7] << ((int)shiftCount[7] & 7)),
                (byte)(value[8] << ((int)shiftCount[8] & 7)),
                (byte)(value[9] << ((int)shiftCount[9] & 7)),
                (byte)(value[10] << ((int)shiftCount[10] & 7)),
                (byte)(value[11] << ((int)shiftCount[11] & 7)),
                (byte)(value[12] << ((int)shiftCount[12] & 7)),
                (byte)(value[13] << ((int)shiftCount[13] & 7)),
                (byte)(value[14] << ((int)shiftCount[14] & 7)),
                (byte)(value[15] << ((int)shiftCount[15] & 7)),
                (byte)(value[16] << ((int)shiftCount[16] & 7)),
                (byte)(value[17] << ((int)shiftCount[17] & 7)),
                (byte)(value[18] << ((int)shiftCount[18] & 7)),
                (byte)(value[19] << ((int)shiftCount[19] & 7)),
                (byte)(value[20] << ((int)shiftCount[20] & 7)),
                (byte)(value[21] << ((int)shiftCount[21] & 7)),
                (byte)(value[22] << ((int)shiftCount[22] & 7)),
                (byte)(value[23] << ((int)shiftCount[23] & 7)),
                (byte)(value[24] << ((int)shiftCount[24] & 7)),
                (byte)(value[25] << ((int)shiftCount[25] & 7)),
                (byte)(value[26] << ((int)shiftCount[26] & 7)),
                (byte)(value[27] << ((int)shiftCount[27] & 7)),
                (byte)(value[28] << ((int)shiftCount[28] & 7)),
                (byte)(value[29] << ((int)shiftCount[29] & 7)),
                (byte)(value[30] << ((int)shiftCount[30] & 7)),
                (byte)(value[31] << ((int)shiftCount[31] & 7)),
            });
        default:
            {
                var buffer = (stackalloc byte[Vector<byte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (byte)(value[i] << ((int)shiftCount[i] & 7));
                }
                return Unsafe.As<byte, Vector<byte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<ushort> ShiftLeft(Vector<ushort> value, Vector<ushort> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<ushort> ShiftLeftFallback(Vector<ushort> value, Vector<ushort> shiftCount)
    {
        switch(Vector<ushort>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] << ((int)shiftCount[0] & 15)),
                (ushort)(value[1] << ((int)shiftCount[1] & 15)),
                (ushort)(value[2] << ((int)shiftCount[2] & 15)),
                (ushort)(value[3] << ((int)shiftCount[3] & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] << ((int)shiftCount[0] & 15)),
                (ushort)(value[1] << ((int)shiftCount[1] & 15)),
                (ushort)(value[2] << ((int)shiftCount[2] & 15)),
                (ushort)(value[3] << ((int)shiftCount[3] & 15)),
                (ushort)(value[4] << ((int)shiftCount[4] & 15)),
                (ushort)(value[5] << ((int)shiftCount[5] & 15)),
                (ushort)(value[6] << ((int)shiftCount[6] & 15)),
                (ushort)(value[7] << ((int)shiftCount[7] & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] << ((int)shiftCount[0] & 15)),
                (ushort)(value[1] << ((int)shiftCount[1] & 15)),
                (ushort)(value[2] << ((int)shiftCount[2] & 15)),
                (ushort)(value[3] << ((int)shiftCount[3] & 15)),
                (ushort)(value[4] << ((int)shiftCount[4] & 15)),
                (ushort)(value[5] << ((int)shiftCount[5] & 15)),
                (ushort)(value[6] << ((int)shiftCount[6] & 15)),
                (ushort)(value[7] << ((int)shiftCount[7] & 15)),
                (ushort)(value[8] << ((int)shiftCount[8] & 15)),
                (ushort)(value[9] << ((int)shiftCount[9] & 15)),
                (ushort)(value[10] << ((int)shiftCount[10] & 15)),
                (ushort)(value[11] << ((int)shiftCount[11] & 15)),
                (ushort)(value[12] << ((int)shiftCount[12] & 15)),
                (ushort)(value[13] << ((int)shiftCount[13] & 15)),
                (ushort)(value[14] << ((int)shiftCount[14] & 15)),
                (ushort)(value[15] << ((int)shiftCount[15] & 15)),
            });
        default:
            {
                var buffer = (stackalloc ushort[Vector<ushort>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (ushort)(value[i] << ((int)shiftCount[i] & 15));
                }
                return Unsafe.As<ushort, Vector<ushort>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<uint> ShiftLeft(Vector<uint> value, Vector<uint> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<uint>.Count == Vector256<uint>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<uint>.Count == Vector128<uint>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<uint> ShiftLeftFallback(Vector<uint> value, Vector<uint> shiftCount)
    {
        switch(Vector<uint>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] << ((int)shiftCount[0] & 31)),
                (uint)(value[1] << ((int)shiftCount[1] & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] << ((int)shiftCount[0] & 31)),
                (uint)(value[1] << ((int)shiftCount[1] & 31)),
                (uint)(value[2] << ((int)shiftCount[2] & 31)),
                (uint)(value[3] << ((int)shiftCount[3] & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] << ((int)shiftCount[0] & 31)),
                (uint)(value[1] << ((int)shiftCount[1] & 31)),
                (uint)(value[2] << ((int)shiftCount[2] & 31)),
                (uint)(value[3] << ((int)shiftCount[3] & 31)),
                (uint)(value[4] << ((int)shiftCount[4] & 31)),
                (uint)(value[5] << ((int)shiftCount[5] & 31)),
                (uint)(value[6] << ((int)shiftCount[6] & 31)),
                (uint)(value[7] << ((int)shiftCount[7] & 31)),
            });
        default:
            {
                var buffer = (stackalloc uint[Vector<uint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (uint)(value[i] << ((int)shiftCount[i] & 31));
                }
                return Unsafe.As<uint, Vector<uint>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<ulong> ShiftLeft(Vector<ulong> value, Vector<ulong> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<ulong>.Count == Vector256<ulong>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._63));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<ulong>.Count == Vector128<ulong>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._63));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<ulong> ShiftLeftFallback(Vector<ulong> value, Vector<ulong> shiftCount)
    {
        switch(Vector<ulong>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] << ((int)shiftCount[0] & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] << ((int)shiftCount[0] & 63)),
                (ulong)(value[1] << ((int)shiftCount[1] & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] << ((int)shiftCount[0] & 63)),
                (ulong)(value[1] << ((int)shiftCount[1] & 63)),
                (ulong)(value[2] << ((int)shiftCount[2] & 63)),
                (ulong)(value[3] << ((int)shiftCount[3] & 63)),
            });
        default:
            {
                var buffer = (stackalloc ulong[Vector<ulong>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (ulong)(value[i] << ((int)shiftCount[i] & 63));
                }
                return Unsafe.As<ulong, Vector<ulong>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nuint> ShiftLeft(Vector<nuint> value, Vector<nuint> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<nuint> ShiftLeftFallback(Vector<nuint> value, Vector<nuint> shiftCount)
    {
        switch(Vector<nuint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] << ((int)shiftCount[0] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] << ((int)shiftCount[0] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] << ((int)shiftCount[1] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] << ((int)shiftCount[0] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] << ((int)shiftCount[1] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[2] << ((int)shiftCount[2] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[3] << ((int)shiftCount[3] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] << ((int)shiftCount[0] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] << ((int)shiftCount[1] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[2] << ((int)shiftCount[2] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[3] << ((int)shiftCount[3] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[4] << ((int)shiftCount[4] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[5] << ((int)shiftCount[5] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[6] << ((int)shiftCount[6] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[7] << ((int)shiftCount[7] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nuint[Vector<nuint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nuint)(value[i] << ((int)shiftCount[i] & (Unsafe.SizeOf<nuint>() * 8 - 1)));
                }
                return Unsafe.As<nuint, Vector<nuint>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<sbyte> ShiftLeft(Vector<sbyte> value, Vector<sbyte> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<sbyte> ShiftLeftFallback(Vector<sbyte> value, Vector<sbyte> shiftCount)
    {
        switch(Vector<sbyte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] << ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] << ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] << ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] << ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] << ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] << ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] << ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] << ((int)shiftCount[7] & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] << ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] << ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] << ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] << ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] << ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] << ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] << ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] << ((int)shiftCount[7] & 7)),
                (sbyte)(value[8] << ((int)shiftCount[8] & 7)),
                (sbyte)(value[9] << ((int)shiftCount[9] & 7)),
                (sbyte)(value[10] << ((int)shiftCount[10] & 7)),
                (sbyte)(value[11] << ((int)shiftCount[11] & 7)),
                (sbyte)(value[12] << ((int)shiftCount[12] & 7)),
                (sbyte)(value[13] << ((int)shiftCount[13] & 7)),
                (sbyte)(value[14] << ((int)shiftCount[14] & 7)),
                (sbyte)(value[15] << ((int)shiftCount[15] & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] << ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] << ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] << ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] << ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] << ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] << ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] << ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] << ((int)shiftCount[7] & 7)),
                (sbyte)(value[8] << ((int)shiftCount[8] & 7)),
                (sbyte)(value[9] << ((int)shiftCount[9] & 7)),
                (sbyte)(value[10] << ((int)shiftCount[10] & 7)),
                (sbyte)(value[11] << ((int)shiftCount[11] & 7)),
                (sbyte)(value[12] << ((int)shiftCount[12] & 7)),
                (sbyte)(value[13] << ((int)shiftCount[13] & 7)),
                (sbyte)(value[14] << ((int)shiftCount[14] & 7)),
                (sbyte)(value[15] << ((int)shiftCount[15] & 7)),
                (sbyte)(value[16] << ((int)shiftCount[16] & 7)),
                (sbyte)(value[17] << ((int)shiftCount[17] & 7)),
                (sbyte)(value[18] << ((int)shiftCount[18] & 7)),
                (sbyte)(value[19] << ((int)shiftCount[19] & 7)),
                (sbyte)(value[20] << ((int)shiftCount[20] & 7)),
                (sbyte)(value[21] << ((int)shiftCount[21] & 7)),
                (sbyte)(value[22] << ((int)shiftCount[22] & 7)),
                (sbyte)(value[23] << ((int)shiftCount[23] & 7)),
                (sbyte)(value[24] << ((int)shiftCount[24] & 7)),
                (sbyte)(value[25] << ((int)shiftCount[25] & 7)),
                (sbyte)(value[26] << ((int)shiftCount[26] & 7)),
                (sbyte)(value[27] << ((int)shiftCount[27] & 7)),
                (sbyte)(value[28] << ((int)shiftCount[28] & 7)),
                (sbyte)(value[29] << ((int)shiftCount[29] & 7)),
                (sbyte)(value[30] << ((int)shiftCount[30] & 7)),
                (sbyte)(value[31] << ((int)shiftCount[31] & 7)),
            });
        default:
            {
                var buffer = (stackalloc sbyte[Vector<sbyte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (sbyte)(value[i] << ((int)shiftCount[i] & 7));
                }
                return Unsafe.As<sbyte, Vector<sbyte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<short> ShiftLeft(Vector<short> value, Vector<short> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<short> ShiftLeftFallback(Vector<short> value, Vector<short> shiftCount)
    {
        switch(Vector<short>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] << ((int)shiftCount[0] & 15)),
                (short)(value[1] << ((int)shiftCount[1] & 15)),
                (short)(value[2] << ((int)shiftCount[2] & 15)),
                (short)(value[3] << ((int)shiftCount[3] & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] << ((int)shiftCount[0] & 15)),
                (short)(value[1] << ((int)shiftCount[1] & 15)),
                (short)(value[2] << ((int)shiftCount[2] & 15)),
                (short)(value[3] << ((int)shiftCount[3] & 15)),
                (short)(value[4] << ((int)shiftCount[4] & 15)),
                (short)(value[5] << ((int)shiftCount[5] & 15)),
                (short)(value[6] << ((int)shiftCount[6] & 15)),
                (short)(value[7] << ((int)shiftCount[7] & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] << ((int)shiftCount[0] & 15)),
                (short)(value[1] << ((int)shiftCount[1] & 15)),
                (short)(value[2] << ((int)shiftCount[2] & 15)),
                (short)(value[3] << ((int)shiftCount[3] & 15)),
                (short)(value[4] << ((int)shiftCount[4] & 15)),
                (short)(value[5] << ((int)shiftCount[5] & 15)),
                (short)(value[6] << ((int)shiftCount[6] & 15)),
                (short)(value[7] << ((int)shiftCount[7] & 15)),
                (short)(value[8] << ((int)shiftCount[8] & 15)),
                (short)(value[9] << ((int)shiftCount[9] & 15)),
                (short)(value[10] << ((int)shiftCount[10] & 15)),
                (short)(value[11] << ((int)shiftCount[11] & 15)),
                (short)(value[12] << ((int)shiftCount[12] & 15)),
                (short)(value[13] << ((int)shiftCount[13] & 15)),
                (short)(value[14] << ((int)shiftCount[14] & 15)),
                (short)(value[15] << ((int)shiftCount[15] & 15)),
            });
        default:
            {
                var buffer = (stackalloc short[Vector<short>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (short)(value[i] << ((int)shiftCount[i] & 15));
                }
                return Unsafe.As<short, Vector<short>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<int> ShiftLeft(Vector<int> value, Vector<int> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<int>.Count == Vector256<int>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<int>.Count == Vector128<int>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<int> ShiftLeftFallback(Vector<int> value, Vector<int> shiftCount)
    {
        switch(Vector<int>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] << ((int)shiftCount[0] & 31)),
                (int)(value[1] << ((int)shiftCount[1] & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] << ((int)shiftCount[0] & 31)),
                (int)(value[1] << ((int)shiftCount[1] & 31)),
                (int)(value[2] << ((int)shiftCount[2] & 31)),
                (int)(value[3] << ((int)shiftCount[3] & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] << ((int)shiftCount[0] & 31)),
                (int)(value[1] << ((int)shiftCount[1] & 31)),
                (int)(value[2] << ((int)shiftCount[2] & 31)),
                (int)(value[3] << ((int)shiftCount[3] & 31)),
                (int)(value[4] << ((int)shiftCount[4] & 31)),
                (int)(value[5] << ((int)shiftCount[5] & 31)),
                (int)(value[6] << ((int)shiftCount[6] & 31)),
                (int)(value[7] << ((int)shiftCount[7] & 31)),
            });
        default:
            {
                var buffer = (stackalloc int[Vector<int>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (int)(value[i] << ((int)shiftCount[i] & 31));
                }
                return Unsafe.As<int, Vector<int>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<long> ShiftLeft(Vector<long> value, Vector<long> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<long>.Count == Vector256<long>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._63));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<long>.Count == Vector128<long>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._63));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<long> ShiftLeftFallback(Vector<long> value, Vector<long> shiftCount)
    {
        switch(Vector<long>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] << ((int)shiftCount[0] & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] << ((int)shiftCount[0] & 63)),
                (long)(value[1] << ((int)shiftCount[1] & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] << ((int)shiftCount[0] & 63)),
                (long)(value[1] << ((int)shiftCount[1] & 63)),
                (long)(value[2] << ((int)shiftCount[2] & 63)),
                (long)(value[3] << ((int)shiftCount[3] & 63)),
            });
        default:
            {
                var buffer = (stackalloc long[Vector<long>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (long)(value[i] << ((int)shiftCount[i] & 63));
                }
                return Unsafe.As<long, Vector<long>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nint> ShiftLeft(Vector<nint> value, Vector<nint> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<nint> ShiftLeftFallback(Vector<nint> value, Vector<nint> shiftCount)
    {
        switch(Vector<nint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] << ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] << ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] << ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] << ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] << ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] << ((int)shiftCount[2] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] << ((int)shiftCount[3] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] << ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] << ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] << ((int)shiftCount[2] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] << ((int)shiftCount[3] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[4] << ((int)shiftCount[4] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[5] << ((int)shiftCount[5] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[6] << ((int)shiftCount[6] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[7] << ((int)shiftCount[7] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nint[Vector<nint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nint)(value[i] << ((int)shiftCount[i] & (Unsafe.SizeOf<nint>() * 8 - 1)));
                }
                return Unsafe.As<nint, Vector<nint>>(ref buffer[0]);
            }
        }
    }

    #endregion

    #endregion ShiftLeft


    #region ShiftRightLogical

    #region

    public static partial Vector<byte> ShiftRightLogical(Vector<byte> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<byte> ShiftRightLogicalFallback(Vector<byte> value, int shiftCount)
    {
        switch(Vector<byte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] >> (shiftCount & 7)),
                (byte)(value[1] >> (shiftCount & 7)),
                (byte)(value[2] >> (shiftCount & 7)),
                (byte)(value[3] >> (shiftCount & 7)),
                (byte)(value[4] >> (shiftCount & 7)),
                (byte)(value[5] >> (shiftCount & 7)),
                (byte)(value[6] >> (shiftCount & 7)),
                (byte)(value[7] >> (shiftCount & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] >> (shiftCount & 7)),
                (byte)(value[1] >> (shiftCount & 7)),
                (byte)(value[2] >> (shiftCount & 7)),
                (byte)(value[3] >> (shiftCount & 7)),
                (byte)(value[4] >> (shiftCount & 7)),
                (byte)(value[5] >> (shiftCount & 7)),
                (byte)(value[6] >> (shiftCount & 7)),
                (byte)(value[7] >> (shiftCount & 7)),
                (byte)(value[8] >> (shiftCount & 7)),
                (byte)(value[9] >> (shiftCount & 7)),
                (byte)(value[10] >> (shiftCount & 7)),
                (byte)(value[11] >> (shiftCount & 7)),
                (byte)(value[12] >> (shiftCount & 7)),
                (byte)(value[13] >> (shiftCount & 7)),
                (byte)(value[14] >> (shiftCount & 7)),
                (byte)(value[15] >> (shiftCount & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] >> (shiftCount & 7)),
                (byte)(value[1] >> (shiftCount & 7)),
                (byte)(value[2] >> (shiftCount & 7)),
                (byte)(value[3] >> (shiftCount & 7)),
                (byte)(value[4] >> (shiftCount & 7)),
                (byte)(value[5] >> (shiftCount & 7)),
                (byte)(value[6] >> (shiftCount & 7)),
                (byte)(value[7] >> (shiftCount & 7)),
                (byte)(value[8] >> (shiftCount & 7)),
                (byte)(value[9] >> (shiftCount & 7)),
                (byte)(value[10] >> (shiftCount & 7)),
                (byte)(value[11] >> (shiftCount & 7)),
                (byte)(value[12] >> (shiftCount & 7)),
                (byte)(value[13] >> (shiftCount & 7)),
                (byte)(value[14] >> (shiftCount & 7)),
                (byte)(value[15] >> (shiftCount & 7)),
                (byte)(value[16] >> (shiftCount & 7)),
                (byte)(value[17] >> (shiftCount & 7)),
                (byte)(value[18] >> (shiftCount & 7)),
                (byte)(value[19] >> (shiftCount & 7)),
                (byte)(value[20] >> (shiftCount & 7)),
                (byte)(value[21] >> (shiftCount & 7)),
                (byte)(value[22] >> (shiftCount & 7)),
                (byte)(value[23] >> (shiftCount & 7)),
                (byte)(value[24] >> (shiftCount & 7)),
                (byte)(value[25] >> (shiftCount & 7)),
                (byte)(value[26] >> (shiftCount & 7)),
                (byte)(value[27] >> (shiftCount & 7)),
                (byte)(value[28] >> (shiftCount & 7)),
                (byte)(value[29] >> (shiftCount & 7)),
                (byte)(value[30] >> (shiftCount & 7)),
                (byte)(value[31] >> (shiftCount & 7)),
            });
        default:
            {
                var buffer = (stackalloc byte[Vector<byte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (byte)(value[i] >> (shiftCount & 7));
                }
                return Unsafe.As<byte, Vector<byte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<ushort> ShiftRightLogical(Vector<ushort> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<ushort>.Count == Vector256<ushort>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
        if(Vector<ushort>.Count == Vector128<ushort>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<ushort> ShiftRightLogicalFallback(Vector<ushort> value, int shiftCount)
    {
        switch(Vector<ushort>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] >> (shiftCount & 15)),
                (ushort)(value[1] >> (shiftCount & 15)),
                (ushort)(value[2] >> (shiftCount & 15)),
                (ushort)(value[3] >> (shiftCount & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] >> (shiftCount & 15)),
                (ushort)(value[1] >> (shiftCount & 15)),
                (ushort)(value[2] >> (shiftCount & 15)),
                (ushort)(value[3] >> (shiftCount & 15)),
                (ushort)(value[4] >> (shiftCount & 15)),
                (ushort)(value[5] >> (shiftCount & 15)),
                (ushort)(value[6] >> (shiftCount & 15)),
                (ushort)(value[7] >> (shiftCount & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] >> (shiftCount & 15)),
                (ushort)(value[1] >> (shiftCount & 15)),
                (ushort)(value[2] >> (shiftCount & 15)),
                (ushort)(value[3] >> (shiftCount & 15)),
                (ushort)(value[4] >> (shiftCount & 15)),
                (ushort)(value[5] >> (shiftCount & 15)),
                (ushort)(value[6] >> (shiftCount & 15)),
                (ushort)(value[7] >> (shiftCount & 15)),
                (ushort)(value[8] >> (shiftCount & 15)),
                (ushort)(value[9] >> (shiftCount & 15)),
                (ushort)(value[10] >> (shiftCount & 15)),
                (ushort)(value[11] >> (shiftCount & 15)),
                (ushort)(value[12] >> (shiftCount & 15)),
                (ushort)(value[13] >> (shiftCount & 15)),
                (ushort)(value[14] >> (shiftCount & 15)),
                (ushort)(value[15] >> (shiftCount & 15)),
            });
        default:
            {
                var buffer = (stackalloc ushort[Vector<ushort>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (ushort)(value[i] >> (shiftCount & 15));
                }
                return Unsafe.As<ushort, Vector<ushort>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<uint> ShiftRightLogical(Vector<uint> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<uint>.Count == Vector256<uint>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
        if(Vector<uint>.Count == Vector128<uint>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<uint> ShiftRightLogicalFallback(Vector<uint> value, int shiftCount)
    {
        switch(Vector<uint>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] >> (shiftCount & 31)),
                (uint)(value[1] >> (shiftCount & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] >> (shiftCount & 31)),
                (uint)(value[1] >> (shiftCount & 31)),
                (uint)(value[2] >> (shiftCount & 31)),
                (uint)(value[3] >> (shiftCount & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] >> (shiftCount & 31)),
                (uint)(value[1] >> (shiftCount & 31)),
                (uint)(value[2] >> (shiftCount & 31)),
                (uint)(value[3] >> (shiftCount & 31)),
                (uint)(value[4] >> (shiftCount & 31)),
                (uint)(value[5] >> (shiftCount & 31)),
                (uint)(value[6] >> (shiftCount & 31)),
                (uint)(value[7] >> (shiftCount & 31)),
            });
        default:
            {
                var buffer = (stackalloc uint[Vector<uint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (uint)(value[i] >> (shiftCount & 31));
                }
                return Unsafe.As<uint, Vector<uint>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<ulong> ShiftRightLogical(Vector<ulong> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<ulong>.Count == Vector256<ulong>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
        if(Vector<ulong>.Count == Vector128<ulong>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<ulong> ShiftRightLogicalFallback(Vector<ulong> value, int shiftCount)
    {
        switch(Vector<ulong>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] >> (shiftCount & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] >> (shiftCount & 63)),
                (ulong)(value[1] >> (shiftCount & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] >> (shiftCount & 63)),
                (ulong)(value[1] >> (shiftCount & 63)),
                (ulong)(value[2] >> (shiftCount & 63)),
                (ulong)(value[3] >> (shiftCount & 63)),
            });
        default:
            {
                var buffer = (stackalloc ulong[Vector<ulong>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (ulong)(value[i] >> (shiftCount & 63));
                }
                return Unsafe.As<ulong, Vector<ulong>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nuint> ShiftRightLogical(Vector<nuint> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<nuint> ShiftRightLogicalFallback(Vector<nuint> value, int shiftCount)
    {
        switch(Vector<nuint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[2] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[3] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[2] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[3] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[4] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[5] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[6] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[7] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nuint[Vector<nuint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nuint)(value[i] >> (shiftCount & (Unsafe.SizeOf<nuint>() * 8 - 1)));
                }
                return Unsafe.As<nuint, Vector<nuint>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<sbyte> ShiftRightLogical(Vector<sbyte> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<sbyte> ShiftRightLogicalFallback(Vector<sbyte> value, int shiftCount)
    {
        switch(Vector<sbyte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> (shiftCount & 7)),
                (sbyte)(value[1] >> (shiftCount & 7)),
                (sbyte)(value[2] >> (shiftCount & 7)),
                (sbyte)(value[3] >> (shiftCount & 7)),
                (sbyte)(value[4] >> (shiftCount & 7)),
                (sbyte)(value[5] >> (shiftCount & 7)),
                (sbyte)(value[6] >> (shiftCount & 7)),
                (sbyte)(value[7] >> (shiftCount & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> (shiftCount & 7)),
                (sbyte)(value[1] >> (shiftCount & 7)),
                (sbyte)(value[2] >> (shiftCount & 7)),
                (sbyte)(value[3] >> (shiftCount & 7)),
                (sbyte)(value[4] >> (shiftCount & 7)),
                (sbyte)(value[5] >> (shiftCount & 7)),
                (sbyte)(value[6] >> (shiftCount & 7)),
                (sbyte)(value[7] >> (shiftCount & 7)),
                (sbyte)(value[8] >> (shiftCount & 7)),
                (sbyte)(value[9] >> (shiftCount & 7)),
                (sbyte)(value[10] >> (shiftCount & 7)),
                (sbyte)(value[11] >> (shiftCount & 7)),
                (sbyte)(value[12] >> (shiftCount & 7)),
                (sbyte)(value[13] >> (shiftCount & 7)),
                (sbyte)(value[14] >> (shiftCount & 7)),
                (sbyte)(value[15] >> (shiftCount & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> (shiftCount & 7)),
                (sbyte)(value[1] >> (shiftCount & 7)),
                (sbyte)(value[2] >> (shiftCount & 7)),
                (sbyte)(value[3] >> (shiftCount & 7)),
                (sbyte)(value[4] >> (shiftCount & 7)),
                (sbyte)(value[5] >> (shiftCount & 7)),
                (sbyte)(value[6] >> (shiftCount & 7)),
                (sbyte)(value[7] >> (shiftCount & 7)),
                (sbyte)(value[8] >> (shiftCount & 7)),
                (sbyte)(value[9] >> (shiftCount & 7)),
                (sbyte)(value[10] >> (shiftCount & 7)),
                (sbyte)(value[11] >> (shiftCount & 7)),
                (sbyte)(value[12] >> (shiftCount & 7)),
                (sbyte)(value[13] >> (shiftCount & 7)),
                (sbyte)(value[14] >> (shiftCount & 7)),
                (sbyte)(value[15] >> (shiftCount & 7)),
                (sbyte)(value[16] >> (shiftCount & 7)),
                (sbyte)(value[17] >> (shiftCount & 7)),
                (sbyte)(value[18] >> (shiftCount & 7)),
                (sbyte)(value[19] >> (shiftCount & 7)),
                (sbyte)(value[20] >> (shiftCount & 7)),
                (sbyte)(value[21] >> (shiftCount & 7)),
                (sbyte)(value[22] >> (shiftCount & 7)),
                (sbyte)(value[23] >> (shiftCount & 7)),
                (sbyte)(value[24] >> (shiftCount & 7)),
                (sbyte)(value[25] >> (shiftCount & 7)),
                (sbyte)(value[26] >> (shiftCount & 7)),
                (sbyte)(value[27] >> (shiftCount & 7)),
                (sbyte)(value[28] >> (shiftCount & 7)),
                (sbyte)(value[29] >> (shiftCount & 7)),
                (sbyte)(value[30] >> (shiftCount & 7)),
                (sbyte)(value[31] >> (shiftCount & 7)),
            });
        default:
            {
                var buffer = (stackalloc sbyte[Vector<sbyte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (sbyte)(value[i] >> (shiftCount & 7));
                }
                return Unsafe.As<sbyte, Vector<sbyte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<short> ShiftRightLogical(Vector<short> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<short>.Count == Vector256<short>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
        if(Vector<short>.Count == Vector128<short>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<short> ShiftRightLogicalFallback(Vector<short> value, int shiftCount)
    {
        switch(Vector<short>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> (shiftCount & 15)),
                (short)(value[1] >> (shiftCount & 15)),
                (short)(value[2] >> (shiftCount & 15)),
                (short)(value[3] >> (shiftCount & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> (shiftCount & 15)),
                (short)(value[1] >> (shiftCount & 15)),
                (short)(value[2] >> (shiftCount & 15)),
                (short)(value[3] >> (shiftCount & 15)),
                (short)(value[4] >> (shiftCount & 15)),
                (short)(value[5] >> (shiftCount & 15)),
                (short)(value[6] >> (shiftCount & 15)),
                (short)(value[7] >> (shiftCount & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> (shiftCount & 15)),
                (short)(value[1] >> (shiftCount & 15)),
                (short)(value[2] >> (shiftCount & 15)),
                (short)(value[3] >> (shiftCount & 15)),
                (short)(value[4] >> (shiftCount & 15)),
                (short)(value[5] >> (shiftCount & 15)),
                (short)(value[6] >> (shiftCount & 15)),
                (short)(value[7] >> (shiftCount & 15)),
                (short)(value[8] >> (shiftCount & 15)),
                (short)(value[9] >> (shiftCount & 15)),
                (short)(value[10] >> (shiftCount & 15)),
                (short)(value[11] >> (shiftCount & 15)),
                (short)(value[12] >> (shiftCount & 15)),
                (short)(value[13] >> (shiftCount & 15)),
                (short)(value[14] >> (shiftCount & 15)),
                (short)(value[15] >> (shiftCount & 15)),
            });
        default:
            {
                var buffer = (stackalloc short[Vector<short>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (short)(value[i] >> (shiftCount & 15));
                }
                return Unsafe.As<short, Vector<short>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<int> ShiftRightLogical(Vector<int> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<int>.Count == Vector256<int>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
        if(Vector<int>.Count == Vector128<int>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<int> ShiftRightLogicalFallback(Vector<int> value, int shiftCount)
    {
        switch(Vector<int>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> (shiftCount & 31)),
                (int)(value[1] >> (shiftCount & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> (shiftCount & 31)),
                (int)(value[1] >> (shiftCount & 31)),
                (int)(value[2] >> (shiftCount & 31)),
                (int)(value[3] >> (shiftCount & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> (shiftCount & 31)),
                (int)(value[1] >> (shiftCount & 31)),
                (int)(value[2] >> (shiftCount & 31)),
                (int)(value[3] >> (shiftCount & 31)),
                (int)(value[4] >> (shiftCount & 31)),
                (int)(value[5] >> (shiftCount & 31)),
                (int)(value[6] >> (shiftCount & 31)),
                (int)(value[7] >> (shiftCount & 31)),
            });
        default:
            {
                var buffer = (stackalloc int[Vector<int>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (int)(value[i] >> (shiftCount & 31));
                }
                return Unsafe.As<int, Vector<int>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<long> ShiftRightLogical(Vector<long> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<long>.Count == Vector256<long>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
        if(Vector<long>.Count == Vector128<long>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<long> ShiftRightLogicalFallback(Vector<long> value, int shiftCount)
    {
        switch(Vector<long>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> (shiftCount & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> (shiftCount & 63)),
                (long)(value[1] >> (shiftCount & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> (shiftCount & 63)),
                (long)(value[1] >> (shiftCount & 63)),
                (long)(value[2] >> (shiftCount & 63)),
                (long)(value[3] >> (shiftCount & 63)),
            });
        default:
            {
                var buffer = (stackalloc long[Vector<long>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (long)(value[i] >> (shiftCount & 63));
                }
                return Unsafe.As<long, Vector<long>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nint> ShiftRightLogical(Vector<nint> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<nint> ShiftRightLogicalFallback(Vector<nint> value, int shiftCount)
    {
        switch(Vector<nint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[4] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[5] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[6] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[7] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nint[Vector<nint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nint)(value[i] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1)));
                }
                return Unsafe.As<nint, Vector<nint>>(ref buffer[0]);
            }
        }
    }

    #endregion

    #region

    public static partial Vector<byte> ShiftRightLogical(Vector<byte> value, Vector<byte> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<byte> ShiftRightLogicalFallback(Vector<byte> value, Vector<byte> shiftCount)
    {
        switch(Vector<byte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] >> ((int)shiftCount[0] & 7)),
                (byte)(value[1] >> ((int)shiftCount[1] & 7)),
                (byte)(value[2] >> ((int)shiftCount[2] & 7)),
                (byte)(value[3] >> ((int)shiftCount[3] & 7)),
                (byte)(value[4] >> ((int)shiftCount[4] & 7)),
                (byte)(value[5] >> ((int)shiftCount[5] & 7)),
                (byte)(value[6] >> ((int)shiftCount[6] & 7)),
                (byte)(value[7] >> ((int)shiftCount[7] & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] >> ((int)shiftCount[0] & 7)),
                (byte)(value[1] >> ((int)shiftCount[1] & 7)),
                (byte)(value[2] >> ((int)shiftCount[2] & 7)),
                (byte)(value[3] >> ((int)shiftCount[3] & 7)),
                (byte)(value[4] >> ((int)shiftCount[4] & 7)),
                (byte)(value[5] >> ((int)shiftCount[5] & 7)),
                (byte)(value[6] >> ((int)shiftCount[6] & 7)),
                (byte)(value[7] >> ((int)shiftCount[7] & 7)),
                (byte)(value[8] >> ((int)shiftCount[8] & 7)),
                (byte)(value[9] >> ((int)shiftCount[9] & 7)),
                (byte)(value[10] >> ((int)shiftCount[10] & 7)),
                (byte)(value[11] >> ((int)shiftCount[11] & 7)),
                (byte)(value[12] >> ((int)shiftCount[12] & 7)),
                (byte)(value[13] >> ((int)shiftCount[13] & 7)),
                (byte)(value[14] >> ((int)shiftCount[14] & 7)),
                (byte)(value[15] >> ((int)shiftCount[15] & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (byte)(value[0] >> ((int)shiftCount[0] & 7)),
                (byte)(value[1] >> ((int)shiftCount[1] & 7)),
                (byte)(value[2] >> ((int)shiftCount[2] & 7)),
                (byte)(value[3] >> ((int)shiftCount[3] & 7)),
                (byte)(value[4] >> ((int)shiftCount[4] & 7)),
                (byte)(value[5] >> ((int)shiftCount[5] & 7)),
                (byte)(value[6] >> ((int)shiftCount[6] & 7)),
                (byte)(value[7] >> ((int)shiftCount[7] & 7)),
                (byte)(value[8] >> ((int)shiftCount[8] & 7)),
                (byte)(value[9] >> ((int)shiftCount[9] & 7)),
                (byte)(value[10] >> ((int)shiftCount[10] & 7)),
                (byte)(value[11] >> ((int)shiftCount[11] & 7)),
                (byte)(value[12] >> ((int)shiftCount[12] & 7)),
                (byte)(value[13] >> ((int)shiftCount[13] & 7)),
                (byte)(value[14] >> ((int)shiftCount[14] & 7)),
                (byte)(value[15] >> ((int)shiftCount[15] & 7)),
                (byte)(value[16] >> ((int)shiftCount[16] & 7)),
                (byte)(value[17] >> ((int)shiftCount[17] & 7)),
                (byte)(value[18] >> ((int)shiftCount[18] & 7)),
                (byte)(value[19] >> ((int)shiftCount[19] & 7)),
                (byte)(value[20] >> ((int)shiftCount[20] & 7)),
                (byte)(value[21] >> ((int)shiftCount[21] & 7)),
                (byte)(value[22] >> ((int)shiftCount[22] & 7)),
                (byte)(value[23] >> ((int)shiftCount[23] & 7)),
                (byte)(value[24] >> ((int)shiftCount[24] & 7)),
                (byte)(value[25] >> ((int)shiftCount[25] & 7)),
                (byte)(value[26] >> ((int)shiftCount[26] & 7)),
                (byte)(value[27] >> ((int)shiftCount[27] & 7)),
                (byte)(value[28] >> ((int)shiftCount[28] & 7)),
                (byte)(value[29] >> ((int)shiftCount[29] & 7)),
                (byte)(value[30] >> ((int)shiftCount[30] & 7)),
                (byte)(value[31] >> ((int)shiftCount[31] & 7)),
            });
        default:
            {
                var buffer = (stackalloc byte[Vector<byte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (byte)(value[i] >> ((int)shiftCount[i] & 7));
                }
                return Unsafe.As<byte, Vector<byte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<ushort> ShiftRightLogical(Vector<ushort> value, Vector<ushort> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<ushort> ShiftRightLogicalFallback(Vector<ushort> value, Vector<ushort> shiftCount)
    {
        switch(Vector<ushort>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] >> ((int)shiftCount[0] & 15)),
                (ushort)(value[1] >> ((int)shiftCount[1] & 15)),
                (ushort)(value[2] >> ((int)shiftCount[2] & 15)),
                (ushort)(value[3] >> ((int)shiftCount[3] & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] >> ((int)shiftCount[0] & 15)),
                (ushort)(value[1] >> ((int)shiftCount[1] & 15)),
                (ushort)(value[2] >> ((int)shiftCount[2] & 15)),
                (ushort)(value[3] >> ((int)shiftCount[3] & 15)),
                (ushort)(value[4] >> ((int)shiftCount[4] & 15)),
                (ushort)(value[5] >> ((int)shiftCount[5] & 15)),
                (ushort)(value[6] >> ((int)shiftCount[6] & 15)),
                (ushort)(value[7] >> ((int)shiftCount[7] & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (ushort)(value[0] >> ((int)shiftCount[0] & 15)),
                (ushort)(value[1] >> ((int)shiftCount[1] & 15)),
                (ushort)(value[2] >> ((int)shiftCount[2] & 15)),
                (ushort)(value[3] >> ((int)shiftCount[3] & 15)),
                (ushort)(value[4] >> ((int)shiftCount[4] & 15)),
                (ushort)(value[5] >> ((int)shiftCount[5] & 15)),
                (ushort)(value[6] >> ((int)shiftCount[6] & 15)),
                (ushort)(value[7] >> ((int)shiftCount[7] & 15)),
                (ushort)(value[8] >> ((int)shiftCount[8] & 15)),
                (ushort)(value[9] >> ((int)shiftCount[9] & 15)),
                (ushort)(value[10] >> ((int)shiftCount[10] & 15)),
                (ushort)(value[11] >> ((int)shiftCount[11] & 15)),
                (ushort)(value[12] >> ((int)shiftCount[12] & 15)),
                (ushort)(value[13] >> ((int)shiftCount[13] & 15)),
                (ushort)(value[14] >> ((int)shiftCount[14] & 15)),
                (ushort)(value[15] >> ((int)shiftCount[15] & 15)),
            });
        default:
            {
                var buffer = (stackalloc ushort[Vector<ushort>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (ushort)(value[i] >> ((int)shiftCount[i] & 15));
                }
                return Unsafe.As<ushort, Vector<ushort>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<uint> ShiftRightLogical(Vector<uint> value, Vector<uint> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<uint>.Count == Vector256<uint>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<uint>.Count == Vector128<uint>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<uint> ShiftRightLogicalFallback(Vector<uint> value, Vector<uint> shiftCount)
    {
        switch(Vector<uint>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] >> ((int)shiftCount[0] & 31)),
                (uint)(value[1] >> ((int)shiftCount[1] & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] >> ((int)shiftCount[0] & 31)),
                (uint)(value[1] >> ((int)shiftCount[1] & 31)),
                (uint)(value[2] >> ((int)shiftCount[2] & 31)),
                (uint)(value[3] >> ((int)shiftCount[3] & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (uint)(value[0] >> ((int)shiftCount[0] & 31)),
                (uint)(value[1] >> ((int)shiftCount[1] & 31)),
                (uint)(value[2] >> ((int)shiftCount[2] & 31)),
                (uint)(value[3] >> ((int)shiftCount[3] & 31)),
                (uint)(value[4] >> ((int)shiftCount[4] & 31)),
                (uint)(value[5] >> ((int)shiftCount[5] & 31)),
                (uint)(value[6] >> ((int)shiftCount[6] & 31)),
                (uint)(value[7] >> ((int)shiftCount[7] & 31)),
            });
        default:
            {
                var buffer = (stackalloc uint[Vector<uint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (uint)(value[i] >> ((int)shiftCount[i] & 31));
                }
                return Unsafe.As<uint, Vector<uint>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<ulong> ShiftRightLogical(Vector<ulong> value, Vector<ulong> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<ulong>.Count == Vector256<ulong>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._63));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<ulong>.Count == Vector128<ulong>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._63));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<ulong> ShiftRightLogicalFallback(Vector<ulong> value, Vector<ulong> shiftCount)
    {
        switch(Vector<ulong>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] >> ((int)shiftCount[0] & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] >> ((int)shiftCount[0] & 63)),
                (ulong)(value[1] >> ((int)shiftCount[1] & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (ulong)(value[0] >> ((int)shiftCount[0] & 63)),
                (ulong)(value[1] >> ((int)shiftCount[1] & 63)),
                (ulong)(value[2] >> ((int)shiftCount[2] & 63)),
                (ulong)(value[3] >> ((int)shiftCount[3] & 63)),
            });
        default:
            {
                var buffer = (stackalloc ulong[Vector<ulong>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (ulong)(value[i] >> ((int)shiftCount[i] & 63));
                }
                return Unsafe.As<ulong, Vector<ulong>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nuint> ShiftRightLogical(Vector<nuint> value, Vector<nuint> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<nuint> ShiftRightLogicalFallback(Vector<nuint> value, Vector<nuint> shiftCount)
    {
        switch(Vector<nuint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[2] >> ((int)shiftCount[2] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[3] >> ((int)shiftCount[3] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nuint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[2] >> ((int)shiftCount[2] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[3] >> ((int)shiftCount[3] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[4] >> ((int)shiftCount[4] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[5] >> ((int)shiftCount[5] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[6] >> ((int)shiftCount[6] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
                (nuint)(value[7] >> ((int)shiftCount[7] & (Unsafe.SizeOf<nuint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nuint[Vector<nuint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nuint)(value[i] >> ((int)shiftCount[i] & (Unsafe.SizeOf<nuint>() * 8 - 1)));
                }
                return Unsafe.As<nuint, Vector<nuint>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<sbyte> ShiftRightLogical(Vector<sbyte> value, Vector<sbyte> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<sbyte> ShiftRightLogicalFallback(Vector<sbyte> value, Vector<sbyte> shiftCount)
    {
        switch(Vector<sbyte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] >> ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] >> ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] >> ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] >> ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] >> ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] >> ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] >> ((int)shiftCount[7] & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] >> ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] >> ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] >> ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] >> ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] >> ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] >> ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] >> ((int)shiftCount[7] & 7)),
                (sbyte)(value[8] >> ((int)shiftCount[8] & 7)),
                (sbyte)(value[9] >> ((int)shiftCount[9] & 7)),
                (sbyte)(value[10] >> ((int)shiftCount[10] & 7)),
                (sbyte)(value[11] >> ((int)shiftCount[11] & 7)),
                (sbyte)(value[12] >> ((int)shiftCount[12] & 7)),
                (sbyte)(value[13] >> ((int)shiftCount[13] & 7)),
                (sbyte)(value[14] >> ((int)shiftCount[14] & 7)),
                (sbyte)(value[15] >> ((int)shiftCount[15] & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] >> ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] >> ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] >> ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] >> ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] >> ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] >> ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] >> ((int)shiftCount[7] & 7)),
                (sbyte)(value[8] >> ((int)shiftCount[8] & 7)),
                (sbyte)(value[9] >> ((int)shiftCount[9] & 7)),
                (sbyte)(value[10] >> ((int)shiftCount[10] & 7)),
                (sbyte)(value[11] >> ((int)shiftCount[11] & 7)),
                (sbyte)(value[12] >> ((int)shiftCount[12] & 7)),
                (sbyte)(value[13] >> ((int)shiftCount[13] & 7)),
                (sbyte)(value[14] >> ((int)shiftCount[14] & 7)),
                (sbyte)(value[15] >> ((int)shiftCount[15] & 7)),
                (sbyte)(value[16] >> ((int)shiftCount[16] & 7)),
                (sbyte)(value[17] >> ((int)shiftCount[17] & 7)),
                (sbyte)(value[18] >> ((int)shiftCount[18] & 7)),
                (sbyte)(value[19] >> ((int)shiftCount[19] & 7)),
                (sbyte)(value[20] >> ((int)shiftCount[20] & 7)),
                (sbyte)(value[21] >> ((int)shiftCount[21] & 7)),
                (sbyte)(value[22] >> ((int)shiftCount[22] & 7)),
                (sbyte)(value[23] >> ((int)shiftCount[23] & 7)),
                (sbyte)(value[24] >> ((int)shiftCount[24] & 7)),
                (sbyte)(value[25] >> ((int)shiftCount[25] & 7)),
                (sbyte)(value[26] >> ((int)shiftCount[26] & 7)),
                (sbyte)(value[27] >> ((int)shiftCount[27] & 7)),
                (sbyte)(value[28] >> ((int)shiftCount[28] & 7)),
                (sbyte)(value[29] >> ((int)shiftCount[29] & 7)),
                (sbyte)(value[30] >> ((int)shiftCount[30] & 7)),
                (sbyte)(value[31] >> ((int)shiftCount[31] & 7)),
            });
        default:
            {
                var buffer = (stackalloc sbyte[Vector<sbyte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (sbyte)(value[i] >> ((int)shiftCount[i] & 7));
                }
                return Unsafe.As<sbyte, Vector<sbyte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<short> ShiftRightLogical(Vector<short> value, Vector<short> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<short> ShiftRightLogicalFallback(Vector<short> value, Vector<short> shiftCount)
    {
        switch(Vector<short>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> ((int)shiftCount[0] & 15)),
                (short)(value[1] >> ((int)shiftCount[1] & 15)),
                (short)(value[2] >> ((int)shiftCount[2] & 15)),
                (short)(value[3] >> ((int)shiftCount[3] & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> ((int)shiftCount[0] & 15)),
                (short)(value[1] >> ((int)shiftCount[1] & 15)),
                (short)(value[2] >> ((int)shiftCount[2] & 15)),
                (short)(value[3] >> ((int)shiftCount[3] & 15)),
                (short)(value[4] >> ((int)shiftCount[4] & 15)),
                (short)(value[5] >> ((int)shiftCount[5] & 15)),
                (short)(value[6] >> ((int)shiftCount[6] & 15)),
                (short)(value[7] >> ((int)shiftCount[7] & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> ((int)shiftCount[0] & 15)),
                (short)(value[1] >> ((int)shiftCount[1] & 15)),
                (short)(value[2] >> ((int)shiftCount[2] & 15)),
                (short)(value[3] >> ((int)shiftCount[3] & 15)),
                (short)(value[4] >> ((int)shiftCount[4] & 15)),
                (short)(value[5] >> ((int)shiftCount[5] & 15)),
                (short)(value[6] >> ((int)shiftCount[6] & 15)),
                (short)(value[7] >> ((int)shiftCount[7] & 15)),
                (short)(value[8] >> ((int)shiftCount[8] & 15)),
                (short)(value[9] >> ((int)shiftCount[9] & 15)),
                (short)(value[10] >> ((int)shiftCount[10] & 15)),
                (short)(value[11] >> ((int)shiftCount[11] & 15)),
                (short)(value[12] >> ((int)shiftCount[12] & 15)),
                (short)(value[13] >> ((int)shiftCount[13] & 15)),
                (short)(value[14] >> ((int)shiftCount[14] & 15)),
                (short)(value[15] >> ((int)shiftCount[15] & 15)),
            });
        default:
            {
                var buffer = (stackalloc short[Vector<short>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (short)(value[i] >> ((int)shiftCount[i] & 15));
                }
                return Unsafe.As<short, Vector<short>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<int> ShiftRightLogical(Vector<int> value, Vector<int> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<int>.Count == Vector256<int>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<int>.Count == Vector128<int>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<int> ShiftRightLogicalFallback(Vector<int> value, Vector<int> shiftCount)
    {
        switch(Vector<int>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> ((int)shiftCount[0] & 31)),
                (int)(value[1] >> ((int)shiftCount[1] & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> ((int)shiftCount[0] & 31)),
                (int)(value[1] >> ((int)shiftCount[1] & 31)),
                (int)(value[2] >> ((int)shiftCount[2] & 31)),
                (int)(value[3] >> ((int)shiftCount[3] & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> ((int)shiftCount[0] & 31)),
                (int)(value[1] >> ((int)shiftCount[1] & 31)),
                (int)(value[2] >> ((int)shiftCount[2] & 31)),
                (int)(value[3] >> ((int)shiftCount[3] & 31)),
                (int)(value[4] >> ((int)shiftCount[4] & 31)),
                (int)(value[5] >> ((int)shiftCount[5] & 31)),
                (int)(value[6] >> ((int)shiftCount[6] & 31)),
                (int)(value[7] >> ((int)shiftCount[7] & 31)),
            });
        default:
            {
                var buffer = (stackalloc int[Vector<int>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (int)(value[i] >> ((int)shiftCount[i] & 31));
                }
                return Unsafe.As<int, Vector<int>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<long> ShiftRightLogical(Vector<long> value, Vector<long> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<long>.Count == Vector256<long>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._63));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<long>.Count == Vector128<long>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._63));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<long> ShiftRightLogicalFallback(Vector<long> value, Vector<long> shiftCount)
    {
        switch(Vector<long>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> ((int)shiftCount[0] & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> ((int)shiftCount[0] & 63)),
                (long)(value[1] >> ((int)shiftCount[1] & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> ((int)shiftCount[0] & 63)),
                (long)(value[1] >> ((int)shiftCount[1] & 63)),
                (long)(value[2] >> ((int)shiftCount[2] & 63)),
                (long)(value[3] >> ((int)shiftCount[3] & 63)),
            });
        default:
            {
                var buffer = (stackalloc long[Vector<long>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (long)(value[i] >> ((int)shiftCount[i] & 63));
                }
                return Unsafe.As<long, Vector<long>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nint> ShiftRightLogical(Vector<nint> value, Vector<nint> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<nint> ShiftRightLogicalFallback(Vector<nint> value, Vector<nint> shiftCount)
    {
        switch(Vector<nint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] >> ((int)shiftCount[2] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] >> ((int)shiftCount[3] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] >> ((int)shiftCount[2] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] >> ((int)shiftCount[3] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[4] >> ((int)shiftCount[4] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[5] >> ((int)shiftCount[5] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[6] >> ((int)shiftCount[6] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[7] >> ((int)shiftCount[7] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nint[Vector<nint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nint)(value[i] >> ((int)shiftCount[i] & (Unsafe.SizeOf<nint>() * 8 - 1)));
                }
                return Unsafe.As<nint, Vector<nint>>(ref buffer[0]);
            }
        }
    }

    #endregion

    #endregion ShiftRightLogical


    #region ShiftRightArithmetic

    #region

    public static partial Vector<sbyte> ShiftRightArithmetic(Vector<sbyte> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightArithmetic(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }

    internal static Vector<sbyte> ShiftRightArithmeticFallback(Vector<sbyte> value, int shiftCount)
    {
        switch(Vector<sbyte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> (shiftCount & 7)),
                (sbyte)(value[1] >> (shiftCount & 7)),
                (sbyte)(value[2] >> (shiftCount & 7)),
                (sbyte)(value[3] >> (shiftCount & 7)),
                (sbyte)(value[4] >> (shiftCount & 7)),
                (sbyte)(value[5] >> (shiftCount & 7)),
                (sbyte)(value[6] >> (shiftCount & 7)),
                (sbyte)(value[7] >> (shiftCount & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> (shiftCount & 7)),
                (sbyte)(value[1] >> (shiftCount & 7)),
                (sbyte)(value[2] >> (shiftCount & 7)),
                (sbyte)(value[3] >> (shiftCount & 7)),
                (sbyte)(value[4] >> (shiftCount & 7)),
                (sbyte)(value[5] >> (shiftCount & 7)),
                (sbyte)(value[6] >> (shiftCount & 7)),
                (sbyte)(value[7] >> (shiftCount & 7)),
                (sbyte)(value[8] >> (shiftCount & 7)),
                (sbyte)(value[9] >> (shiftCount & 7)),
                (sbyte)(value[10] >> (shiftCount & 7)),
                (sbyte)(value[11] >> (shiftCount & 7)),
                (sbyte)(value[12] >> (shiftCount & 7)),
                (sbyte)(value[13] >> (shiftCount & 7)),
                (sbyte)(value[14] >> (shiftCount & 7)),
                (sbyte)(value[15] >> (shiftCount & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> (shiftCount & 7)),
                (sbyte)(value[1] >> (shiftCount & 7)),
                (sbyte)(value[2] >> (shiftCount & 7)),
                (sbyte)(value[3] >> (shiftCount & 7)),
                (sbyte)(value[4] >> (shiftCount & 7)),
                (sbyte)(value[5] >> (shiftCount & 7)),
                (sbyte)(value[6] >> (shiftCount & 7)),
                (sbyte)(value[7] >> (shiftCount & 7)),
                (sbyte)(value[8] >> (shiftCount & 7)),
                (sbyte)(value[9] >> (shiftCount & 7)),
                (sbyte)(value[10] >> (shiftCount & 7)),
                (sbyte)(value[11] >> (shiftCount & 7)),
                (sbyte)(value[12] >> (shiftCount & 7)),
                (sbyte)(value[13] >> (shiftCount & 7)),
                (sbyte)(value[14] >> (shiftCount & 7)),
                (sbyte)(value[15] >> (shiftCount & 7)),
                (sbyte)(value[16] >> (shiftCount & 7)),
                (sbyte)(value[17] >> (shiftCount & 7)),
                (sbyte)(value[18] >> (shiftCount & 7)),
                (sbyte)(value[19] >> (shiftCount & 7)),
                (sbyte)(value[20] >> (shiftCount & 7)),
                (sbyte)(value[21] >> (shiftCount & 7)),
                (sbyte)(value[22] >> (shiftCount & 7)),
                (sbyte)(value[23] >> (shiftCount & 7)),
                (sbyte)(value[24] >> (shiftCount & 7)),
                (sbyte)(value[25] >> (shiftCount & 7)),
                (sbyte)(value[26] >> (shiftCount & 7)),
                (sbyte)(value[27] >> (shiftCount & 7)),
                (sbyte)(value[28] >> (shiftCount & 7)),
                (sbyte)(value[29] >> (shiftCount & 7)),
                (sbyte)(value[30] >> (shiftCount & 7)),
                (sbyte)(value[31] >> (shiftCount & 7)),
            });
        default:
            {
                var buffer = (stackalloc sbyte[Vector<sbyte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (sbyte)(value[i] >> (shiftCount & 7));
                }
                return Unsafe.As<sbyte, Vector<sbyte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<short> ShiftRightArithmetic(Vector<short> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightArithmetic(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<short>.Count == Vector256<short>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightArithmetic(xvalue, (byte)shiftCount));
        }
        if(Vector<short>.Count == Vector128<short>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightArithmetic(xvalue, (byte)shiftCount));
        }
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }

    internal static Vector<short> ShiftRightArithmeticFallback(Vector<short> value, int shiftCount)
    {
        switch(Vector<short>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> (shiftCount & 15)),
                (short)(value[1] >> (shiftCount & 15)),
                (short)(value[2] >> (shiftCount & 15)),
                (short)(value[3] >> (shiftCount & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> (shiftCount & 15)),
                (short)(value[1] >> (shiftCount & 15)),
                (short)(value[2] >> (shiftCount & 15)),
                (short)(value[3] >> (shiftCount & 15)),
                (short)(value[4] >> (shiftCount & 15)),
                (short)(value[5] >> (shiftCount & 15)),
                (short)(value[6] >> (shiftCount & 15)),
                (short)(value[7] >> (shiftCount & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> (shiftCount & 15)),
                (short)(value[1] >> (shiftCount & 15)),
                (short)(value[2] >> (shiftCount & 15)),
                (short)(value[3] >> (shiftCount & 15)),
                (short)(value[4] >> (shiftCount & 15)),
                (short)(value[5] >> (shiftCount & 15)),
                (short)(value[6] >> (shiftCount & 15)),
                (short)(value[7] >> (shiftCount & 15)),
                (short)(value[8] >> (shiftCount & 15)),
                (short)(value[9] >> (shiftCount & 15)),
                (short)(value[10] >> (shiftCount & 15)),
                (short)(value[11] >> (shiftCount & 15)),
                (short)(value[12] >> (shiftCount & 15)),
                (short)(value[13] >> (shiftCount & 15)),
                (short)(value[14] >> (shiftCount & 15)),
                (short)(value[15] >> (shiftCount & 15)),
            });
        default:
            {
                var buffer = (stackalloc short[Vector<short>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (short)(value[i] >> (shiftCount & 15));
                }
                return Unsafe.As<short, Vector<short>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<int> ShiftRightArithmetic(Vector<int> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightArithmetic(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
        if(Vector<int>.Count == Vector256<int>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightArithmetic(xvalue, (byte)shiftCount));
        }
        if(Vector<int>.Count == Vector128<int>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightArithmetic(xvalue, (byte)shiftCount));
        }
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }

    internal static Vector<int> ShiftRightArithmeticFallback(Vector<int> value, int shiftCount)
    {
        switch(Vector<int>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> (shiftCount & 31)),
                (int)(value[1] >> (shiftCount & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> (shiftCount & 31)),
                (int)(value[1] >> (shiftCount & 31)),
                (int)(value[2] >> (shiftCount & 31)),
                (int)(value[3] >> (shiftCount & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> (shiftCount & 31)),
                (int)(value[1] >> (shiftCount & 31)),
                (int)(value[2] >> (shiftCount & 31)),
                (int)(value[3] >> (shiftCount & 31)),
                (int)(value[4] >> (shiftCount & 31)),
                (int)(value[5] >> (shiftCount & 31)),
                (int)(value[6] >> (shiftCount & 31)),
                (int)(value[7] >> (shiftCount & 31)),
            });
        default:
            {
                var buffer = (stackalloc int[Vector<int>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (int)(value[i] >> (shiftCount & 31));
                }
                return Unsafe.As<int, Vector<int>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<long> ShiftRightArithmetic(Vector<long> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightArithmetic(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }

    internal static Vector<long> ShiftRightArithmeticFallback(Vector<long> value, int shiftCount)
    {
        switch(Vector<long>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> (shiftCount & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> (shiftCount & 63)),
                (long)(value[1] >> (shiftCount & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> (shiftCount & 63)),
                (long)(value[1] >> (shiftCount & 63)),
                (long)(value[2] >> (shiftCount & 63)),
                (long)(value[3] >> (shiftCount & 63)),
            });
        default:
            {
                var buffer = (stackalloc long[Vector<long>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (long)(value[i] >> (shiftCount & 63));
                }
                return Unsafe.As<long, Vector<long>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nint> ShiftRightArithmetic(Vector<nint> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightArithmetic(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }

    internal static Vector<nint> ShiftRightArithmeticFallback(Vector<nint> value, int shiftCount)
    {
        switch(Vector<nint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[4] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[5] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[6] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[7] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nint[Vector<nint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nint)(value[i] >> (shiftCount & (Unsafe.SizeOf<nint>() * 8 - 1)));
                }
                return Unsafe.As<nint, Vector<nint>>(ref buffer[0]);
            }
        }
    }

    #endregion

    #region

    public static partial Vector<sbyte> ShiftRightArithmetic(Vector<sbyte> value, Vector<sbyte> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }
    
    internal static Vector<sbyte> ShiftRightArithmeticFallback(Vector<sbyte> value, Vector<sbyte> shiftCount)
    {
        switch(Vector<sbyte>.Count)
        {
        case 8:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] >> ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] >> ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] >> ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] >> ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] >> ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] >> ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] >> ((int)shiftCount[7] & 7)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] >> ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] >> ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] >> ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] >> ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] >> ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] >> ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] >> ((int)shiftCount[7] & 7)),
                (sbyte)(value[8] >> ((int)shiftCount[8] & 7)),
                (sbyte)(value[9] >> ((int)shiftCount[9] & 7)),
                (sbyte)(value[10] >> ((int)shiftCount[10] & 7)),
                (sbyte)(value[11] >> ((int)shiftCount[11] & 7)),
                (sbyte)(value[12] >> ((int)shiftCount[12] & 7)),
                (sbyte)(value[13] >> ((int)shiftCount[13] & 7)),
                (sbyte)(value[14] >> ((int)shiftCount[14] & 7)),
                (sbyte)(value[15] >> ((int)shiftCount[15] & 7)),
            });
        case 32:
            return H.CreateVector(stackalloc [] {
                (sbyte)(value[0] >> ((int)shiftCount[0] & 7)),
                (sbyte)(value[1] >> ((int)shiftCount[1] & 7)),
                (sbyte)(value[2] >> ((int)shiftCount[2] & 7)),
                (sbyte)(value[3] >> ((int)shiftCount[3] & 7)),
                (sbyte)(value[4] >> ((int)shiftCount[4] & 7)),
                (sbyte)(value[5] >> ((int)shiftCount[5] & 7)),
                (sbyte)(value[6] >> ((int)shiftCount[6] & 7)),
                (sbyte)(value[7] >> ((int)shiftCount[7] & 7)),
                (sbyte)(value[8] >> ((int)shiftCount[8] & 7)),
                (sbyte)(value[9] >> ((int)shiftCount[9] & 7)),
                (sbyte)(value[10] >> ((int)shiftCount[10] & 7)),
                (sbyte)(value[11] >> ((int)shiftCount[11] & 7)),
                (sbyte)(value[12] >> ((int)shiftCount[12] & 7)),
                (sbyte)(value[13] >> ((int)shiftCount[13] & 7)),
                (sbyte)(value[14] >> ((int)shiftCount[14] & 7)),
                (sbyte)(value[15] >> ((int)shiftCount[15] & 7)),
                (sbyte)(value[16] >> ((int)shiftCount[16] & 7)),
                (sbyte)(value[17] >> ((int)shiftCount[17] & 7)),
                (sbyte)(value[18] >> ((int)shiftCount[18] & 7)),
                (sbyte)(value[19] >> ((int)shiftCount[19] & 7)),
                (sbyte)(value[20] >> ((int)shiftCount[20] & 7)),
                (sbyte)(value[21] >> ((int)shiftCount[21] & 7)),
                (sbyte)(value[22] >> ((int)shiftCount[22] & 7)),
                (sbyte)(value[23] >> ((int)shiftCount[23] & 7)),
                (sbyte)(value[24] >> ((int)shiftCount[24] & 7)),
                (sbyte)(value[25] >> ((int)shiftCount[25] & 7)),
                (sbyte)(value[26] >> ((int)shiftCount[26] & 7)),
                (sbyte)(value[27] >> ((int)shiftCount[27] & 7)),
                (sbyte)(value[28] >> ((int)shiftCount[28] & 7)),
                (sbyte)(value[29] >> ((int)shiftCount[29] & 7)),
                (sbyte)(value[30] >> ((int)shiftCount[30] & 7)),
                (sbyte)(value[31] >> ((int)shiftCount[31] & 7)),
            });
        default:
            {
                var buffer = (stackalloc sbyte[Vector<sbyte>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (sbyte)(value[i] >> ((int)shiftCount[i] & 7));
                }
                return Unsafe.As<sbyte, Vector<sbyte>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<short> ShiftRightArithmetic(Vector<short> value, Vector<short> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }
    
    internal static Vector<short> ShiftRightArithmeticFallback(Vector<short> value, Vector<short> shiftCount)
    {
        switch(Vector<short>.Count)
        {
        case 4:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> ((int)shiftCount[0] & 15)),
                (short)(value[1] >> ((int)shiftCount[1] & 15)),
                (short)(value[2] >> ((int)shiftCount[2] & 15)),
                (short)(value[3] >> ((int)shiftCount[3] & 15)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> ((int)shiftCount[0] & 15)),
                (short)(value[1] >> ((int)shiftCount[1] & 15)),
                (short)(value[2] >> ((int)shiftCount[2] & 15)),
                (short)(value[3] >> ((int)shiftCount[3] & 15)),
                (short)(value[4] >> ((int)shiftCount[4] & 15)),
                (short)(value[5] >> ((int)shiftCount[5] & 15)),
                (short)(value[6] >> ((int)shiftCount[6] & 15)),
                (short)(value[7] >> ((int)shiftCount[7] & 15)),
            });
        case 16:
            return H.CreateVector(stackalloc [] {
                (short)(value[0] >> ((int)shiftCount[0] & 15)),
                (short)(value[1] >> ((int)shiftCount[1] & 15)),
                (short)(value[2] >> ((int)shiftCount[2] & 15)),
                (short)(value[3] >> ((int)shiftCount[3] & 15)),
                (short)(value[4] >> ((int)shiftCount[4] & 15)),
                (short)(value[5] >> ((int)shiftCount[5] & 15)),
                (short)(value[6] >> ((int)shiftCount[6] & 15)),
                (short)(value[7] >> ((int)shiftCount[7] & 15)),
                (short)(value[8] >> ((int)shiftCount[8] & 15)),
                (short)(value[9] >> ((int)shiftCount[9] & 15)),
                (short)(value[10] >> ((int)shiftCount[10] & 15)),
                (short)(value[11] >> ((int)shiftCount[11] & 15)),
                (short)(value[12] >> ((int)shiftCount[12] & 15)),
                (short)(value[13] >> ((int)shiftCount[13] & 15)),
                (short)(value[14] >> ((int)shiftCount[14] & 15)),
                (short)(value[15] >> ((int)shiftCount[15] & 15)),
            });
        default:
            {
                var buffer = (stackalloc short[Vector<short>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (short)(value[i] >> ((int)shiftCount[i] & 15));
                }
                return Unsafe.As<short, Vector<short>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<int> ShiftRightArithmetic(Vector<int> value, Vector<int> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
        if(Vector<int>.Count == Vector256<int>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftRightArithmeticVariable(xvalue, xshiftCount));
        }
        if(Vector<int>.Count == Vector128<int>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._31));
            return H.AsVector(Avx2.ShiftRightArithmeticVariable(xvalue, xshiftCount));
        }
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }
    
    internal static Vector<int> ShiftRightArithmeticFallback(Vector<int> value, Vector<int> shiftCount)
    {
        switch(Vector<int>.Count)
        {
        case 2:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> ((int)shiftCount[0] & 31)),
                (int)(value[1] >> ((int)shiftCount[1] & 31)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> ((int)shiftCount[0] & 31)),
                (int)(value[1] >> ((int)shiftCount[1] & 31)),
                (int)(value[2] >> ((int)shiftCount[2] & 31)),
                (int)(value[3] >> ((int)shiftCount[3] & 31)),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (int)(value[0] >> ((int)shiftCount[0] & 31)),
                (int)(value[1] >> ((int)shiftCount[1] & 31)),
                (int)(value[2] >> ((int)shiftCount[2] & 31)),
                (int)(value[3] >> ((int)shiftCount[3] & 31)),
                (int)(value[4] >> ((int)shiftCount[4] & 31)),
                (int)(value[5] >> ((int)shiftCount[5] & 31)),
                (int)(value[6] >> ((int)shiftCount[6] & 31)),
                (int)(value[7] >> ((int)shiftCount[7] & 31)),
            });
        default:
            {
                var buffer = (stackalloc int[Vector<int>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (int)(value[i] >> ((int)shiftCount[i] & 31));
                }
                return Unsafe.As<int, Vector<int>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<long> ShiftRightArithmetic(Vector<long> value, Vector<long> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }
    
    internal static Vector<long> ShiftRightArithmeticFallback(Vector<long> value, Vector<long> shiftCount)
    {
        switch(Vector<long>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> ((int)shiftCount[0] & 63)),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> ((int)shiftCount[0] & 63)),
                (long)(value[1] >> ((int)shiftCount[1] & 63)),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (long)(value[0] >> ((int)shiftCount[0] & 63)),
                (long)(value[1] >> ((int)shiftCount[1] & 63)),
                (long)(value[2] >> ((int)shiftCount[2] & 63)),
                (long)(value[3] >> ((int)shiftCount[3] & 63)),
            });
        default:
            {
                var buffer = (stackalloc long[Vector<long>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (long)(value[i] >> ((int)shiftCount[i] & 63));
                }
                return Unsafe.As<long, Vector<long>>(ref buffer[0]);
            }
        }
    }


    public static partial Vector<nint> ShiftRightArithmetic(Vector<nint> value, Vector<nint> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }
    
    internal static Vector<nint> ShiftRightArithmeticFallback(Vector<nint> value, Vector<nint> shiftCount)
    {
        switch(Vector<nint>.Count)
        {
        case 1:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 2:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 4:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] >> ((int)shiftCount[2] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] >> ((int)shiftCount[3] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        case 8:
            return H.CreateVector(stackalloc [] {
                (nint)(value[0] >> ((int)shiftCount[0] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[1] >> ((int)shiftCount[1] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[2] >> ((int)shiftCount[2] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[3] >> ((int)shiftCount[3] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[4] >> ((int)shiftCount[4] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[5] >> ((int)shiftCount[5] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[6] >> ((int)shiftCount[6] & (Unsafe.SizeOf<nint>() * 8 - 1))),
                (nint)(value[7] >> ((int)shiftCount[7] & (Unsafe.SizeOf<nint>() * 8 - 1))),
            });
        default:
            {
                var buffer = (stackalloc nint[Vector<nint>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (nint)(value[i] >> ((int)shiftCount[i] & (Unsafe.SizeOf<nint>() * 8 - 1)));
                }
                return Unsafe.As<nint, Vector<nint>>(ref buffer[0]);
            }
        }
    }

    #endregion

    #endregion ShiftRightArithmetic
}
