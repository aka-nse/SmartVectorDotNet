<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var none = SupportedOperations.None;
var sll  = SupportedOperations.ShiftLeftLogical;
var sllv = SupportedOperations.ShiftLeftLogicalVariable;
var srl  = SupportedOperations.ShiftRightLogical;
var srlv = SupportedOperations.ShiftRightLogicalVariable;
var sra  = SupportedOperations.ShiftRightArithmetic;
var srav = SupportedOperations.ShiftRightArithmeticVariable;
var unsignedTypes = new TypeDef[]
{
    new("byte"   , none | none | none | none),
    new("ushort" , sll  | none | srl  | none),
    new("uint"   , sll  | sllv | srl  | srlv),
    new("ulong"  , sll  | sllv | srl  | srlv),
    new("nuint"  , none | none | none | none),
};
var signedTypes = new TypeDef[]
{
    new("sbyte"  , none | none | none | none | none | none),
    new("short"  , sll  | none | srl  | none | sra  | none),
    new("int"    , sll  | sllv | srl  | srlv | sra  | srav),
    new("long"   , sll  | sllv | srl  | srlv | none | none),
    new("nint"   , none | none | none | none | none | none),
};
var types = unsignedTypes.Concat(signedTypes);
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.CompilerServices;
#if NETCOREAPP3_0_OR_GREATER
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
#endif
using System.Text;
using NVector = System.Numerics.Vector;
using H = SmartVectorDotNet.InternalHelpers;

#pragma warning disable CS0162

namespace SmartVectorDotNet;

file class BitMasks
{
    public static readonly Vector<uint> _31 = new(31);
    public static readonly Vector<ulong> _63 = new(63);
}


partial class VectorOp
{
    #region ShiftLeft

    #region
<#  foreach(var type in types) { #>

    public static partial Vector<<#=type#>> ShiftLeft(Vector<<#=type#>> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftLeft(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
<#      if(type.SupportedOperations.HasFlag(SupportedOperations.ShiftLeftLogical)) { #>
        if(Vector<<#=type#>>.Count == Vector256<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & <#=type.BitMask#>)));
        }
        if(Vector<<#=type#>>.Count == Vector128<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftLeftLogical(xvalue, (byte)(shiftCount & <#=type.BitMask#>)));
        }
<#      } #>
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<<#=type#>> ShiftLeftFallback(Vector<<#=type#>> value, int shiftCount)
    {
<#      GenerateFallback(type, i => $"value[{i}] << (shiftCount & {type.BitMask})"); #>
    }

<#  } #>
    #endregion

    #region
<#  foreach(var type in types) { #>

    public static partial Vector<<#=type#>> ShiftLeft(Vector<<#=type#>> value, Vector<<#=type#>> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
<#      if(type.SupportedOperations.HasFlag(SupportedOperations.ShiftLeftLogicalVariable)) { #>
        if(Vector<<#=type#>>.Count == Vector256<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._<#=type.BitMask#>));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<<#=type#>>.Count == Vector128<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._<#=type.BitMask#>));
            return H.AsVector(Avx2.ShiftLeftLogicalVariable(xvalue, xshiftCount));
        }
<#      } #>
#endif
        return ShiftLeftFallback(value, shiftCount);
    }
    
    internal static Vector<<#=type#>> ShiftLeftFallback(Vector<<#=type#>> value, Vector<<#=type#>> shiftCount)
    {
<#      GenerateFallback(type, i => $"value[{i}] << ((int)shiftCount[{i}] & {type.BitMask})"); #>
    }

<#  } #>
    #endregion

    #endregion ShiftLeft


    #region ShiftRightLogical

    #region
<#  foreach(var type in types) { #>

    public static partial Vector<<#=type#>> ShiftRightLogical(Vector<<#=type#>> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightLogical(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
<#      if(type.SupportedOperations.HasFlag(SupportedOperations.ShiftRightLogical)) { #>
        if(Vector<<#=type#>>.Count == Vector256<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
        if(Vector<<#=type#>>.Count == Vector128<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightLogical(xvalue, (byte)shiftCount));
        }
<#      } #>
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }
    
    internal static Vector<<#=type#>> ShiftRightLogicalFallback(Vector<<#=type#>> value, int shiftCount)
    {
<#      GenerateFallback(type, i => $"value[{i}] >> (shiftCount & {type.BitMask})"); #>
    }

<#  } #>
    #endregion

    #region
<#  foreach(var type in types) { #>

    public static partial Vector<<#=type#>> ShiftRightLogical(Vector<<#=type#>> value, Vector<<#=type#>> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
<#      if(type.SupportedOperations.HasFlag(SupportedOperations.ShiftRightLogicalVariable)) { #>
        if(Vector<<#=type#>>.Count == Vector256<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._<#=type.BitMask#>));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
        if(Vector<<#=type#>>.Count == Vector128<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._<#=type.BitMask#>));
            return H.AsVector(Avx2.ShiftRightLogicalVariable(xvalue, xshiftCount));
        }
<#      } #>
#endif
        return ShiftRightLogicalFallback(value, shiftCount);
    }

    internal static Vector<<#=type#>> ShiftRightLogicalFallback(Vector<<#=type#>> value, Vector<<#=type#>> shiftCount)
    {
<#      GenerateFallback(type, i => $"value[{i}] >> ((int)shiftCount[{i}] & {type.BitMask})"); #>
    }

<#  } #>
    #endregion

    #endregion ShiftRightLogical


    #region ShiftRightArithmetic

    #region
<#  foreach(var type in signedTypes) { #>

    public static partial Vector<<#=type#>> ShiftRightArithmetic(Vector<<#=type#>> value, int shiftCount)
    {
#if NET7_0_OR_GREATER
        return NVector.ShiftRightArithmetic(value, shiftCount);
#elif NETCOREAPP3_0_OR_GREATER
<#      if(type.SupportedOperations.HasFlag(SupportedOperations.ShiftRightArithmetic)) { #>
        if(Vector<<#=type#>>.Count == Vector256<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector256.AsVector256(value);
            return H.AsVector(Avx2.ShiftRightArithmetic(xvalue, (byte)shiftCount));
        }
        if(Vector<<#=type#>>.Count == Vector128<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = Vector128.AsVector128(value);
            return H.AsVector(Avx2.ShiftRightArithmetic(xvalue, (byte)shiftCount));
        }
<#      } #>
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }

    internal static Vector<<#=type#>> ShiftRightArithmeticFallback(Vector<<#=type#>> value, int shiftCount)
    {
<#      GenerateFallback(type, i => $"value[{i}] >> (shiftCount & {type.BitMask})"); #>
    }

<#  } #>
    #endregion

    #region
<#  foreach(var type in signedTypes) { #>

    public static partial Vector<<#=type#>> ShiftRightArithmetic(Vector<<#=type#>> value, Vector<<#=type#>> shiftCount)
    {
#if NETCOREAPP3_0_OR_GREATER
<#      if(type.SupportedOperations.HasFlag(SupportedOperations.ShiftRightArithmeticVariable)) { #>
        if(Vector<<#=type#>>.Count == Vector256<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector256(value);
            var xshiftCount = H.AsVector256(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._<#=type.BitMask#>));
            return H.AsVector(Avx2.ShiftRightArithmeticVariable(xvalue, xshiftCount));
        }
        if(Vector<<#=type#>>.Count == Vector128<<#=type#>>.Count && Avx2.IsSupported)
        {
            var xvalue = H.AsVector128(value);
            var xshiftCount = H.AsVector128(BitwiseAnd(H.AsUnsigned(shiftCount), BitMasks._<#=type.BitMask#>));
            return H.AsVector(Avx2.ShiftRightArithmeticVariable(xvalue, xshiftCount));
        }
<#      } #>
#endif
        return ShiftRightArithmeticFallback(value, shiftCount);
    }
    
    internal static Vector<<#=type#>> ShiftRightArithmeticFallback(Vector<<#=type#>> value, Vector<<#=type#>> shiftCount)
    {
<#      GenerateFallback(type, i => $"value[{i}] >> ((int)shiftCount[{i}] & {type.BitMask})"); #>
    }

<#  } #>
    #endregion

    #endregion ShiftRightArithmetic
}
<#+


public void GenerateFallback(string type, Func<string, string> @operator)
{
    var vectorSizes = type switch
    {
        "byte"   or "sbyte" => new [] { 8, 16, 32, },
        "ushort" or "short" => new [] { 4,  8, 16, },
        "uint"   or "int"   => new [] { 2,  4,  8, },
        "ulong"  or "long"  => new [] { 1,  2,  4, },
        "nuint"  or "nint"  => new [] { 1,  2,  4, 8, },
        _ => Array.Empty<int>(),
    };
#>
        switch(Vector<<#=type#>>.Count)
        {
<#+ foreach(var vectorSize in vectorSizes) { #>
        case <#=vectorSize#>:
            return H.CreateVector(stackalloc [] {
<#+     for(var i = 0; i < vectorSize; ++i) { #>
                (<#=type#>)(<#=@operator(i.ToString())#>),
<#+     } #>
            });
<#+ } #>
        default:
            {
                var buffer = (stackalloc <#=type#>[Vector<<#=type#>>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = (<#=type#>)(<#=@operator("i")#>);
                }
                return Unsafe.As<<#=type#>, Vector<<#=type#>>>(ref buffer[0]);
            }
        }
<#+
}


public record TypeDef
{
    public string Name { get; }
    public SupportedOperations SupportedOperations { get; }
    public string BitMask => Name switch
    {
        "byte"   or "sbyte" => "7",
        "ushort" or "short" => "15",
        "uint"   or "int"   => "31",
        "ulong"  or "long"  => "63",
        _ => $"(Unsafe.SizeOf<{Name}>() * 8 - 1)",
    };

    public TypeDef(
        string name,
        SupportedOperations supportedOperations = SupportedOperations.None)
    {
        Name = name;
        SupportedOperations = supportedOperations;
    }

    public override string ToString() => Name;
    public static implicit operator string(TypeDef @this) => @this.Name;
}

[Flags]
public enum SupportedOperations : ulong
{
    None = 0,
    ShiftLeftLogical             = 0b000001,
    ShiftLeftLogicalVariable     = 0b000010,
    ShiftRightLogical            = 0b000100,
    ShiftRightLogicalVariable    = 0b001000,
    ShiftRightArithmetic         = 0b010000,
    ShiftRightArithmeticVariable = 0b100000,
}
#>