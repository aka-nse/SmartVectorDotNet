<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var definitions = new MethodDefinition[] {
    new ("Vector<float > Ceiling(Vector<float > value)", "Ceiling(value)", "float" , "NET6_0_OR_GREATER", element => $"ScalarMath.Ceiling({element})"),
    new ("Vector<double> Ceiling(Vector<double> value)", "Ceiling(value)", "double", "NET6_0_OR_GREATER", element => $"ScalarMath.Ceiling({element})"),
    new ("Vector<float > Floor  (Vector<float > value)", "Floor  (value)", "float" , "NET6_0_OR_GREATER", element => $"ScalarMath.Floor  ({element})"),
    new ("Vector<double> Floor  (Vector<double> value)", "Floor  (value)", "double", "NET6_0_OR_GREATER", element => $"ScalarMath.Floor  ({element})"),
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Text;
using NVector = System.Numerics.Vector;
using static SmartVectorDotNet.InternalHelpers;

namespace SmartVectorDotNet;

partial class VectorOp
{
<#  foreach(var def in definitions) { #>

    public static partial <#=def.MethodDecl#>
    {
#if <#=def.Macro#>
        return NVector.<#=def.MethodCall#>;
#else
        switch(Vector<<#=def.ElementType#>>.Count)
        {
<#      foreach(var size in def.VectorSizes) { #>
        case <#=size#>:
            return CreateVector(stackalloc []{
<#          for(var i = 0; i < size; ++i) { #>
                <#=def.CalcElement($"value[{i}]")#>,
<#          } #>
            });
<#      } #>
        default:
            {
                var buffer = (stackalloc <#=def.ElementType#>[Vector<<#=def.ElementType#>>.Count]);
                for(var i = 0; i < buffer.Length; ++i)
                {
                    buffer[i] = <#=def.CalcElement("value[i]")#>;
                }
                return Unsafe.As<<#=def.ElementType#>, Vector<<#=def.ElementType#>>>(ref buffer[0]);
            }
        }
#endif
    }

<#  } #>
}
<#+

public class MethodDefinition
{
    private static Dictionary<string, int[]> _typeSizes = new ()
    {
        { "byte"  , new []{ 8, 16, 32,    } },
        { "ushort", new []{ 4,  8, 16,    } },
        { "uint"  , new []{ 2,  4,  8,    } },
        { "ulong" , new []{ 1,  2,  4,    } },
        { "nuint" , new []{ 1,  2,  4, 8, } },
        { "sbyte" , new []{ 8, 16, 32,    } },
        { "short" , new []{ 4,  8, 16,    } },
        { "int"   , new []{ 2,  4,  8,    } },
        { "long"  , new []{ 1,  2,  4,    } },
        { "nint"  , new []{ 1,  2,  4, 8, } },
        { "float" , new []{ 2,  4,  8,    } },
        { "double", new []{ 1,  2,  4,    } },
    };

    public string MethodDecl { get; }
    public string MethodCall { get; }
    public string ElementType { get; }
    public string Macro { get; }
    public IReadOnlyList<int> VectorSizes => _typeSizes.TryGetValue(ElementType, out var x) ? x : throw new Exception(ElementType);
    public Func<string, string> CalcElement { get; }

    public MethodDefinition(
        string methodDecl,
        string methodCall,
        string elementType,
        string macro,
        Func<string, string> calcElement)
    {
        MethodDecl = methodDecl;
        MethodCall = methodCall;
        ElementType = elementType;
        Macro = macro;
        CalcElement = calcElement;
    }
}

#>