<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var types = new TypeDef[] {
    //  name      abs    minmax
    new("byte"  , false, true ),
    new("ushort", false, true ),
    new("uint"  , false, true ),
    new("ulong" , false, true ),
    new("sbyte" , true , true ),
    new("short" , true , true ),
    new("int"   , true , true ),
    new("long"  , true , true ),
    new("float ", true , true ),
    new("double", true , true ),
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

using System.Runtime.CompilerServices;
namespace SmartVectorDotNet;

partial class ScalarMath
{
    /// <summary>
    /// Returns the absolute value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Abs<T>(T x) where T : unmanaged
    {
<# foreach(var type in types.Where(type => type.IsAbsSupported)) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(Math.Abs(Reinterpret<T, <#=type#>>(x)));
<# } #>
        #if NET6_0_OR_GREATER
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Math.Abs(Reinterpret<T, nint  >(x)));
        #else
        if (typeof(T) == typeof(nint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<int , T>(Math.Abs(Reinterpret<T, int >(x))),
                8 => Reinterpret<long, T>(Math.Abs(Reinterpret<T, long>(x))),
                _ => throw new NotSupportedException(),
            };
        #endif
        throw new NotSupportedException();
    }


    /// <summary>
    /// Returns the smaller.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Min<T>(T x, T y) where T : unmanaged
    {
<# foreach(var type in types.Where(type => type.IsMinMaxSupported)) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(Math.Min(Reinterpret<T, <#=type#>>(x), Reinterpret<T, <#=type#>>(y)));
<# } #>
        #if NET6_0_OR_GREATER
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Math.Min(Reinterpret<T, nint  >(x), Reinterpret<T, nint  >(y)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(Math.Min(Reinterpret<T, nuint >(x), Reinterpret<T, nuint >(y)));
        #else
        if (typeof(T) == typeof(nint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<int , T>(Math.Min(Reinterpret<T, int >(x), Reinterpret<T, int >(y))),
                8 => Reinterpret<long, T>(Math.Min(Reinterpret<T, long>(x), Reinterpret<T, long>(y))),
                _ => throw new NotSupportedException(),
            };
        if (typeof(T) == typeof(nuint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<uint , T>(Math.Min(Reinterpret<T, uint >(x), Reinterpret<T, uint >(y))),
                8 => Reinterpret<ulong, T>(Math.Min(Reinterpret<T, ulong>(x), Reinterpret<T, ulong>(y))),
                _ => throw new NotSupportedException(),
            };
        #endif
        throw new NotSupportedException();
    }


    /// <summary>
    /// Returns the larger.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Max<T>(T x, T y) where T : unmanaged
    {
<# foreach(var type in types.Where(type => type.IsMinMaxSupported)) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(Math.Max(Reinterpret<T, <#=type#>>(x), Reinterpret<T, <#=type#>>(y)));
<# } #>
        #if NET6_0_OR_GREATER
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Math.Max(Reinterpret<T, nint  >(x), Reinterpret<T, nint  >(y)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(Math.Max(Reinterpret<T, nuint >(x), Reinterpret<T, nuint >(y)));
        #else
        if (typeof(T) == typeof(nint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<int , T>(Math.Max(Reinterpret<T, int >(x), Reinterpret<T, int >(y))),
                8 => Reinterpret<long, T>(Math.Max(Reinterpret<T, long>(x), Reinterpret<T, long>(y))),
                _ => throw new NotSupportedException(),
            };
        if (typeof(T) == typeof(nuint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<uint , T>(Math.Max(Reinterpret<T, uint >(x), Reinterpret<T, uint >(y))),
                8 => Reinterpret<ulong, T>(Math.Max(Reinterpret<T, ulong>(x), Reinterpret<T, ulong>(y))),
                _ => throw new NotSupportedException(),
            };
        #endif
        throw new NotSupportedException();
    }


    /// <summary>
    /// Returns <paramref name="value"/> clamped to the inclusive range of <paramref name="min"/> and <paramref name="max"/>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="value"></param>
    /// <param name="min"></param>
    /// <param name="max"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Clamp<T>(T value, T min, T max) where T : unmanaged
    {
        #if NET6_0_OR_GREATER
<# foreach(var type in types.Where(type => type.IsMinMaxSupported)) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(Math.Clamp(Reinterpret<T, <#=type#>>(value), Reinterpret<T, <#=type#>>(min), Reinterpret<T, <#=type#>>(max)));
<# } #>
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Math.Clamp(Reinterpret<T, nint  >(value), Reinterpret<T, nint  >(min), Reinterpret<T, nint  >(max)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(Math.Clamp(Reinterpret<T, nuint >(value), Reinterpret<T, nuint >(min), Reinterpret<T, nuint >(max)));
        throw new NotSupportedException();
        #else
        return Min(Max(value, min), max);
        #endif
    }
}
<#+
public class TypeDef
{
    public string Name { get; }
    public bool IsAbsSupported { get; }
    public bool IsMinMaxSupported { get; }

    public TypeDef(string name, bool isAbsSupported, bool isMinMaxSupported)
    {
        Name = name;
        IsAbsSupported = isAbsSupported;
        IsMinMaxSupported = isMinMaxSupported;
    }

    public override string ToString() => $"{Name, -6}";
}
#>