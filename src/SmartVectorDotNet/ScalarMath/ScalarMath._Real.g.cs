// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace SmartVectorDotNet;


partial class ScalarMath
{

    /// <summary>
    /// Operates sqrt.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Sqrt<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Sqrt(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Sqrt(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates cos.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Cos<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Cos(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Cos(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates sin.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Sin<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Sin(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Sin(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates tan.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Tan<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Tan(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Tan(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates cosh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Cosh<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Cosh(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Cosh(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates sinh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Sinh<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Sinh(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Sinh(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates tanh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Tanh<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Tanh(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Tanh(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates acos.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Acos<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Acos(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Acos(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates asin.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Asin<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Asin(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Asin(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates atan.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Atan<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Atan(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Atan(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates atan2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Atan2<T>(T y, T x)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var y_ = Reinterpret<T, double>(y);
            var x_ = Reinterpret<T, double>(x);
            return Reinterpret<double, T>(Math.Atan2(y_, x_));
        }
        if(typeof(T) == typeof(float))
        {
            var y_ = Reinterpret<T, float>(y);
            var x_ = Reinterpret<T, float>(x);
            return Reinterpret<float, T>(MathF.Atan2(y_, x_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates ceiling.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Ceiling<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Ceiling(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Ceiling(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates floor.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Floor<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Floor(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Floor(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates exp.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Exp<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Exp(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Exp(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates pow.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Pow<T>(T x, T y)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var x_ = Reinterpret<T, double>(x);
            var y_ = Reinterpret<T, double>(y);
            return Reinterpret<double, T>(Math.Pow(x_, y_));
        }
        if(typeof(T) == typeof(float))
        {
            var x_ = Reinterpret<T, float>(x);
            var y_ = Reinterpret<T, float>(y);
            return Reinterpret<float, T>(MathF.Pow(x_, y_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Log<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Log(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Log(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Log<T>(T d, T newBase)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            var newBase_ = Reinterpret<T, double>(newBase);
            return Reinterpret<double, T>(Math.Log(d_, newBase_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            var newBase_ = Reinterpret<T, float>(newBase);
            return Reinterpret<float, T>(MathF.Log(d_, newBase_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates log10.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Log10<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Log10(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Log10(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates round.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Round<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Round(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Round(d_));
        }
        throw new NotSupportedException();
    }


    /// <summary>
    /// Operates truncate.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Truncate<T>(T d)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Truncate(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Truncate(d_));
        }
        throw new NotSupportedException();
    }



    /// <summary>
    /// Operates acosh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Acosh<T>(T d)
        where T : unmanaged
    {
        #if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Acosh(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Acosh(d_));
        }
        throw new NotSupportedException();
        #else
        return MathEx.Acosh(d);
        #endif
    }


    /// <summary>
    /// Operates asinh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Asinh<T>(T d)
        where T : unmanaged
    {
        #if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Asinh(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Asinh(d_));
        }
        throw new NotSupportedException();
        #else
        return MathEx.Asinh(d);
        #endif
    }


    /// <summary>
    /// Operates atanh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Atanh<T>(T d)
        where T : unmanaged
    {
        #if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Atanh(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Atanh(d_));
        }
        throw new NotSupportedException();
        #else
        return MathEx.Atanh(d);
        #endif
    }


    /// <summary>
    /// Operates cbrt.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Cbrt<T>(T d)
        where T : unmanaged
    {
        #if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Cbrt(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Cbrt(d_));
        }
        throw new NotSupportedException();
        #else
        return MathEx.Cbrt(d);
        #endif
    }


    /// <summary>
    /// Operates log2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Log2<T>(T d)
        where T : unmanaged
    {
        #if NET6_0_OR_GREATER
        if(typeof(T) == typeof(double))
        {
            var d_ = Reinterpret<T, double>(d);
            return Reinterpret<double, T>(Math.Log2(d_));
        }
        if(typeof(T) == typeof(float))
        {
            var d_ = Reinterpret<T, float>(d);
            return Reinterpret<float, T>(MathF.Log2(d_));
        }
        throw new NotSupportedException();
        #else
        return Log(d, ScalarOp.Convert<double, T>(2));
        #endif
    }


}

