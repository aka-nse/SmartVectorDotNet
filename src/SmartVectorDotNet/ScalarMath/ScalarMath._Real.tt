<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var realOps = new RealOpDef[]{
    new("Sqrt", "d"),
    new("Cos", "d"),
    new("Sin", "d"),
    new("Tan", "d"),
    new("Cosh", "d"),
    new("Sinh", "d"),
    new("Tanh", "d"),
    new("Acos", "d"),
    new("Asin", "d"),
    new("Atan", "d"),
    new("Atan2", "y", "x"),
    new("Ceiling", "d"),
    new("Floor", "d"),
    new("Exp", "d"),
    new("Pow", "x", "y"),
    new("Log", "d"),
    new("Log", "d", "newBase"),
    new("Log10", "d"),
    new("Round", "d"),
    new("Truncate", "d"),

    new("Acosh", "d"){ SupportVersionMacro = "NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER", Fallback = "MathEx.Acosh(d)", },
    new("Asinh", "d"){ SupportVersionMacro = "NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER", Fallback = "MathEx.Asinh(d)", },
    new("Atanh", "d"){ SupportVersionMacro = "NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER", Fallback = "MathEx.Atanh(d)", },
    new("Cbrt", "d"){ SupportVersionMacro = "NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER", Fallback = "MathEx.Cbrt(d)", },
    new("Log2", "d"){ SupportVersionMacro = "NET6_0_OR_GREATER", Fallback = "Log(d, ScalarOp.Convert<double, T>(2))", },
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace SmartVectorDotNet;


partial class ScalarMath
{
<# foreach(var realOp in realOps.Where(x => x.SupportVersionMacro is null)) { #>

    /// <summary>
    /// Operates <#=realOp.Name.ToLower()#>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
<#     foreach(var a in realOp.Arguments) { #>
    /// <param name="<#=a#>"></param>
<#     } #>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T <#=realOp#><T>(<#=realOp.ParamDecl#>)
        where T : unmanaged
    {
        if(typeof(T) == typeof(double))
        {
<#     foreach(var a in realOp.Arguments) { #>
            var <#=a#>_ = Reinterpret<T, double>(<#=a#>);
<#     } #>
            return Reinterpret<double, T>(Math.<#=realOp#>(<#=realOp.ParamPass#>));
        }
        if(typeof(T) == typeof(float))
        {
<#     foreach(var a in realOp.Arguments) { #>
            var <#=a#>_ = Reinterpret<T, float>(<#=a#>);
<#     } #>
            return Reinterpret<float, T>(MathF.<#=realOp#>(<#=realOp.ParamPass#>));
        }
        throw new NotSupportedException();
    }

<# } #>

<# foreach(var realOp in realOps.Where(x => x.SupportVersionMacro is not null)) { #>

    /// <summary>
    /// Operates <#=realOp.Name.ToLower()#>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
<#     foreach(var a in realOp.Arguments) { #>
    /// <param name="<#=a#>"></param>
<#     } #>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T <#=realOp#><T>(<#=realOp.ParamDecl#>)
        where T : unmanaged
    {
        #if <#=realOp.SupportVersionMacro#>
        if(typeof(T) == typeof(double))
        {
<#     foreach(var a in realOp.Arguments) { #>
            var <#=a#>_ = Reinterpret<T, double>(<#=a#>);
<#     } #>
            return Reinterpret<double, T>(Math.<#=realOp#>(<#=realOp.ParamPass#>));
        }
        if(typeof(T) == typeof(float))
        {
<#     foreach(var a in realOp.Arguments) { #>
            var <#=a#>_ = Reinterpret<T, float>(<#=a#>);
<#     } #>
            return Reinterpret<float, T>(MathF.<#=realOp#>(<#=realOp.ParamPass#>));
        }
        throw new NotSupportedException();
        #else
        <#= realOp.Fallback is not null ? $"return {realOp.Fallback}" : "throw new NotSupportedException()" #>;
        #endif
    }

<# } #>

}

<#+
public class RealOpDef
{
    public string Name { get; }
    public string[] Arguments { get; }
    public string ParamDecl
        => string.Join(", ", Arguments.Select(a => $"T {a}"));
    public string ParamPass
        => string.Join(", ", Arguments.Select(a => $"{a}_"));
    public string SupportVersionMacro { get; set; }
    public string Fallback { get; set; }

    public RealOpDef(string name, params string[] arguments)
    {
        Name = name;
        Arguments = arguments;
    }

    public override string ToString()
        => Name;
}
#>

