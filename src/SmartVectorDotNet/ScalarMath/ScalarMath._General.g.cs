// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

using System.Runtime.CompilerServices;
namespace SmartVectorDotNet;

partial class ScalarMath
{
    /// <summary>
    /// Returns the absolute value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Abs<T>(T x) where T : unmanaged
    {
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(Math.Abs(Reinterpret<T, sbyte >(x)));
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(Math.Abs(Reinterpret<T, short >(x)));
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(Math.Abs(Reinterpret<T, int   >(x)));
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(Math.Abs(Reinterpret<T, long  >(x)));
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(Math.Abs(Reinterpret<T, float >(x)));
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(Math.Abs(Reinterpret<T, double>(x)));
        #if NET6_0_OR_GREATER
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Math.Abs(Reinterpret<T, nint  >(x)));
        #else
        if (typeof(T) == typeof(nint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<int , T>(Math.Abs(Reinterpret<T, int >(x))),
                8 => Reinterpret<long, T>(Math.Abs(Reinterpret<T, long>(x))),
                _ => throw new NotSupportedException(),
            };
        #endif
        throw new NotSupportedException();
    }


    /// <summary>
    /// Returns the smaller.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Min<T>(T x, T y) where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(Math.Min(Reinterpret<T, byte  >(x), Reinterpret<T, byte  >(y)));
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(Math.Min(Reinterpret<T, ushort>(x), Reinterpret<T, ushort>(y)));
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(Math.Min(Reinterpret<T, uint  >(x), Reinterpret<T, uint  >(y)));
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(Math.Min(Reinterpret<T, ulong >(x), Reinterpret<T, ulong >(y)));
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(Math.Min(Reinterpret<T, sbyte >(x), Reinterpret<T, sbyte >(y)));
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(Math.Min(Reinterpret<T, short >(x), Reinterpret<T, short >(y)));
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(Math.Min(Reinterpret<T, int   >(x), Reinterpret<T, int   >(y)));
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(Math.Min(Reinterpret<T, long  >(x), Reinterpret<T, long  >(y)));
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(Math.Min(Reinterpret<T, float >(x), Reinterpret<T, float >(y)));
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(Math.Min(Reinterpret<T, double>(x), Reinterpret<T, double>(y)));
        #if NET6_0_OR_GREATER
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Math.Min(Reinterpret<T, nint  >(x), Reinterpret<T, nint  >(y)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(Math.Min(Reinterpret<T, nuint >(x), Reinterpret<T, nuint >(y)));
        #else
        if (typeof(T) == typeof(nint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<int , T>(Math.Min(Reinterpret<T, int >(x), Reinterpret<T, int >(y))),
                8 => Reinterpret<long, T>(Math.Min(Reinterpret<T, long>(x), Reinterpret<T, long>(y))),
                _ => throw new NotSupportedException(),
            };
        if (typeof(T) == typeof(nuint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<uint , T>(Math.Min(Reinterpret<T, uint >(x), Reinterpret<T, uint >(y))),
                8 => Reinterpret<ulong, T>(Math.Min(Reinterpret<T, ulong>(x), Reinterpret<T, ulong>(y))),
                _ => throw new NotSupportedException(),
            };
        #endif
        throw new NotSupportedException();
    }


    /// <summary>
    /// Returns the larger.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Max<T>(T x, T y) where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(Math.Max(Reinterpret<T, byte  >(x), Reinterpret<T, byte  >(y)));
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(Math.Max(Reinterpret<T, ushort>(x), Reinterpret<T, ushort>(y)));
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(Math.Max(Reinterpret<T, uint  >(x), Reinterpret<T, uint  >(y)));
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(Math.Max(Reinterpret<T, ulong >(x), Reinterpret<T, ulong >(y)));
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(Math.Max(Reinterpret<T, sbyte >(x), Reinterpret<T, sbyte >(y)));
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(Math.Max(Reinterpret<T, short >(x), Reinterpret<T, short >(y)));
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(Math.Max(Reinterpret<T, int   >(x), Reinterpret<T, int   >(y)));
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(Math.Max(Reinterpret<T, long  >(x), Reinterpret<T, long  >(y)));
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(Math.Max(Reinterpret<T, float >(x), Reinterpret<T, float >(y)));
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(Math.Max(Reinterpret<T, double>(x), Reinterpret<T, double>(y)));
        #if NET6_0_OR_GREATER
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Math.Max(Reinterpret<T, nint  >(x), Reinterpret<T, nint  >(y)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(Math.Max(Reinterpret<T, nuint >(x), Reinterpret<T, nuint >(y)));
        #else
        if (typeof(T) == typeof(nint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<int , T>(Math.Max(Reinterpret<T, int >(x), Reinterpret<T, int >(y))),
                8 => Reinterpret<long, T>(Math.Max(Reinterpret<T, long>(x), Reinterpret<T, long>(y))),
                _ => throw new NotSupportedException(),
            };
        if (typeof(T) == typeof(nuint))
            return IntPtr.Size switch
            {
                4 => Reinterpret<uint , T>(Math.Max(Reinterpret<T, uint >(x), Reinterpret<T, uint >(y))),
                8 => Reinterpret<ulong, T>(Math.Max(Reinterpret<T, ulong>(x), Reinterpret<T, ulong>(y))),
                _ => throw new NotSupportedException(),
            };
        #endif
        throw new NotSupportedException();
    }


    /// <summary>
    /// Returns <paramref name="value"/> clamped to the inclusive range of <paramref name="min"/> and <paramref name="max"/>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="value"></param>
    /// <param name="min"></param>
    /// <param name="max"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException"></exception>
    public static T Clamp<T>(T value, T min, T max) where T : unmanaged
    {
        #if NET6_0_OR_GREATER
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(Math.Clamp(Reinterpret<T, byte  >(value), Reinterpret<T, byte  >(min), Reinterpret<T, byte  >(max)));
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(Math.Clamp(Reinterpret<T, ushort>(value), Reinterpret<T, ushort>(min), Reinterpret<T, ushort>(max)));
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(Math.Clamp(Reinterpret<T, uint  >(value), Reinterpret<T, uint  >(min), Reinterpret<T, uint  >(max)));
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(Math.Clamp(Reinterpret<T, ulong >(value), Reinterpret<T, ulong >(min), Reinterpret<T, ulong >(max)));
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(Math.Clamp(Reinterpret<T, sbyte >(value), Reinterpret<T, sbyte >(min), Reinterpret<T, sbyte >(max)));
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(Math.Clamp(Reinterpret<T, short >(value), Reinterpret<T, short >(min), Reinterpret<T, short >(max)));
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(Math.Clamp(Reinterpret<T, int   >(value), Reinterpret<T, int   >(min), Reinterpret<T, int   >(max)));
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(Math.Clamp(Reinterpret<T, long  >(value), Reinterpret<T, long  >(min), Reinterpret<T, long  >(max)));
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(Math.Clamp(Reinterpret<T, float >(value), Reinterpret<T, float >(min), Reinterpret<T, float >(max)));
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(Math.Clamp(Reinterpret<T, double>(value), Reinterpret<T, double>(min), Reinterpret<T, double>(max)));
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Math.Clamp(Reinterpret<T, nint  >(value), Reinterpret<T, nint  >(min), Reinterpret<T, nint  >(max)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(Math.Clamp(Reinterpret<T, nuint >(value), Reinterpret<T, nuint >(min), Reinterpret<T, nuint >(max)));
        throw new NotSupportedException();
        #else
        return Min(Max(value, min), max);
        #endif
    }
}
