// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace SmartVectorDotNet;

partial class Vectorization
{

    /// <summary>
    /// Operates sqrt.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Sqrt<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        SqrtCore(d, ans);
    }

    /// <summary>
    /// Core implementation for sqrt.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void SqrtCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Sqrt(d[i]);
    }


    /// <summary>
    /// Operates cos.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Cos<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        CosCore(d, ans);
    }

    /// <summary>
    /// Core implementation for cos.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void CosCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Cos(d[i]);
    }


    /// <summary>
    /// Operates sin.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Sin<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        SinCore(d, ans);
    }

    /// <summary>
    /// Core implementation for sin.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void SinCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Sin(d[i]);
    }


    /// <summary>
    /// Operates tan.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Tan<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        TanCore(d, ans);
    }

    /// <summary>
    /// Core implementation for tan.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void TanCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Tan(d[i]);
    }


    /// <summary>
    /// Operates cosh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Cosh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        CoshCore(d, ans);
    }

    /// <summary>
    /// Core implementation for cosh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void CoshCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Cosh(d[i]);
    }


    /// <summary>
    /// Operates sinh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Sinh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        SinhCore(d, ans);
    }

    /// <summary>
    /// Core implementation for sinh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void SinhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Sinh(d[i]);
    }


    /// <summary>
    /// Operates tanh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Tanh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        TanhCore(d, ans);
    }

    /// <summary>
    /// Core implementation for tanh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void TanhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Tanh(d[i]);
    }


    /// <summary>
    /// Operates acos.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Acos<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AcosCore(d, ans);
    }

    /// <summary>
    /// Core implementation for acos.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AcosCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Acos(d[i]);
    }


    /// <summary>
    /// Operates asin.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Asin<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AsinCore(d, ans);
    }

    /// <summary>
    /// Core implementation for asin.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AsinCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Asin(d[i]);
    }


    /// <summary>
    /// Operates atan.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atan<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AtanCore(d, ans);
    }

    /// <summary>
    /// Core implementation for atan.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AtanCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atan(d[i]);
    }


    /// <summary>
    /// Operates acosh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Acosh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AcoshCore(d, ans);
    }

    /// <summary>
    /// Core implementation for acosh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AcoshCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Acosh(d[i]);
    }


    /// <summary>
    /// Operates asinh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Asinh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AsinhCore(d, ans);
    }

    /// <summary>
    /// Core implementation for asinh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AsinhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Asinh(d[i]);
    }


    /// <summary>
    /// Operates atanh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atanh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AtanhCore(d, ans);
    }

    /// <summary>
    /// Core implementation for atanh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AtanhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atanh(d[i]);
    }


    /// <summary>
    /// Operates cbrt.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Cbrt<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        CbrtCore(d, ans);
    }

    /// <summary>
    /// Core implementation for cbrt.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void CbrtCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Cbrt(d[i]);
    }


    /// <summary>
    /// Operates log2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log2<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        Log2Core(d, ans);
    }

    /// <summary>
    /// Core implementation for log2.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Log2Core<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log2(d[i]);
    }


    /// <summary>
    /// Operates ceiling.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Ceiling<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        CeilingCore(d, ans);
    }

    /// <summary>
    /// Core implementation for ceiling.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void CeilingCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Ceiling(d[i]);
    }


    /// <summary>
    /// Operates floor.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Floor<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        FloorCore(d, ans);
    }

    /// <summary>
    /// Core implementation for floor.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void FloorCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Floor(d[i]);
    }


    /// <summary>
    /// Operates exp.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Exp<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        ExpCore(d, ans);
    }

    /// <summary>
    /// Core implementation for exp.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void ExpCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Exp(d[i]);
    }


    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        LogCore(d, ans);
    }

    /// <summary>
    /// Core implementation for log.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void LogCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log(d[i]);
    }


    /// <summary>
    /// Operates log10.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log10<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        Log10Core(d, ans);
    }

    /// <summary>
    /// Core implementation for log10.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Log10Core<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log10(d[i]);
    }


    /// <summary>
    /// Operates round.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Round<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        RoundCore(d, ans);
    }

    /// <summary>
    /// Core implementation for round.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void RoundCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Round(d[i]);
    }


    /// <summary>
    /// Operates truncate.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Truncate<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        TruncateCore(d, ans);
    }

    /// <summary>
    /// Core implementation for truncate.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void TruncateCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Truncate(d[i]);
    }




    /// <summary>
    /// Operates atan2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atan2<T>(T y, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        Atan2Core(y, x, ans);
    }

    /// <summary>
    /// Operates atan2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atan2<T>(ReadOnlySpan<T> y, T x, Span<T> ans)
        where T : unmanaged
    {
        if(y.Length != ans.Length) throw new ArgumentException(nameof(y));
        Atan2Core(y, x, ans);
    }

    /// <summary>
    /// Operates atan2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atan2<T>(ReadOnlySpan<T> y, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        if(y.Length != ans.Length) throw new ArgumentException(nameof(y));
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        Atan2Core(y, x, ans);
    }

    /// <summary>
    /// Core implementation for atan2.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Atan2Core<T>(T y, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atan2(y, x[i]);
    }

    /// <summary>
    /// Core implementation for atan2.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Atan2Core<T>(ReadOnlySpan<T> y, T x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atan2(y[i], x);
    }

    /// <summary>
    /// Core implementation for atan2.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Atan2Core<T>(ReadOnlySpan<T> y, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atan2(y[i], x[i]);
    }


    /// <summary>
    /// Operates pow.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Pow<T>(T x, ReadOnlySpan<T> y, Span<T> ans)
        where T : unmanaged
    {
        if(y.Length != ans.Length) throw new ArgumentException(nameof(y));
        PowCore(x, y, ans);
    }

    /// <summary>
    /// Operates pow.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Pow<T>(ReadOnlySpan<T> x, T y, Span<T> ans)
        where T : unmanaged
    {
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        PowCore(x, y, ans);
    }

    /// <summary>
    /// Operates pow.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Pow<T>(ReadOnlySpan<T> x, ReadOnlySpan<T> y, Span<T> ans)
        where T : unmanaged
    {
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        if(y.Length != ans.Length) throw new ArgumentException(nameof(y));
        PowCore(x, y, ans);
    }

    /// <summary>
    /// Core implementation for pow.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void PowCore<T>(T x, ReadOnlySpan<T> y, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Pow(x, y[i]);
    }

    /// <summary>
    /// Core implementation for pow.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void PowCore<T>(ReadOnlySpan<T> x, T y, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Pow(x[i], y);
    }

    /// <summary>
    /// Core implementation for pow.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void PowCore<T>(ReadOnlySpan<T> x, ReadOnlySpan<T> y, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Pow(x[i], y[i]);
    }


    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log<T>(T d, ReadOnlySpan<T> newBase, Span<T> ans)
        where T : unmanaged
    {
        if(newBase.Length != ans.Length) throw new ArgumentException(nameof(newBase));
        LogCore(d, newBase, ans);
    }

    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log<T>(ReadOnlySpan<T> d, T newBase, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        LogCore(d, newBase, ans);
    }

    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log<T>(ReadOnlySpan<T> d, ReadOnlySpan<T> newBase, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        if(newBase.Length != ans.Length) throw new ArgumentException(nameof(newBase));
        LogCore(d, newBase, ans);
    }

    /// <summary>
    /// Core implementation for log.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void LogCore<T>(T d, ReadOnlySpan<T> newBase, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log(d, newBase[i]);
    }

    /// <summary>
    /// Core implementation for log.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void LogCore<T>(ReadOnlySpan<T> d, T newBase, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log(d[i], newBase);
    }

    /// <summary>
    /// Core implementation for log.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void LogCore<T>(ReadOnlySpan<T> d, ReadOnlySpan<T> newBase, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log(d[i], newBase[i]);
    }


    /// <summary>
    /// Operates scale.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Scale<T>(T n, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        ScaleCore(n, x, ans);
    }

    /// <summary>
    /// Operates scale.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Scale<T>(ReadOnlySpan<T> n, T x, Span<T> ans)
        where T : unmanaged
    {
        if(n.Length != ans.Length) throw new ArgumentException(nameof(n));
        ScaleCore(n, x, ans);
    }

    /// <summary>
    /// Operates scale.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Scale<T>(ReadOnlySpan<T> n, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        if(n.Length != ans.Length) throw new ArgumentException(nameof(n));
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        ScaleCore(n, x, ans);
    }

    /// <summary>
    /// Core implementation for scale.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void ScaleCore<T>(T n, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Scale(n, x[i]);
    }

    /// <summary>
    /// Core implementation for scale.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void ScaleCore<T>(ReadOnlySpan<T> n, T x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Scale(n[i], x);
    }

    /// <summary>
    /// Core implementation for scale.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void ScaleCore<T>(ReadOnlySpan<T> n, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Scale(n[i], x[i]);
    }

}


partial class SimdVectorization
{

    /// <inheritdoc />
    protected internal override void SqrtCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Sqrt(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Sqrt(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void CosCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Cos(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Cos(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void SinCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Sin(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Sin(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void TanCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Tan(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Tan(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void CoshCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Cosh(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Cosh(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void SinhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Sinh(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Sinh(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void TanhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Tanh(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Tanh(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void AcosCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Acos(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Acos(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void AsinCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Asin(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Asin(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void AtanCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Atan(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Atan(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void AcoshCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Acosh(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Acosh(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void AsinhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Asinh(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Asinh(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void AtanhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Atanh(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Atanh(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void CbrtCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Cbrt(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Cbrt(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void Log2Core<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Log2(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Log2(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void CeilingCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Ceiling(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Ceiling(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void FloorCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Floor(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Floor(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void ExpCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Exp(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Exp(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void LogCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Log(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Log(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void Log10Core<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Log10(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Log10(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void RoundCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Round(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Round(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void TruncateCore<T>(ReadOnlySpan<T> d, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Truncate(vectorD[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Truncate(Unsafe.As<T, Vector<T>>(ref vd[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }



    /// <inheritdoc />
    protected internal override void Atan2Core<T>(T y, ReadOnlySpan<T> x, Span<T> ans)
    {
        var vectorY = new Vector<T>(y);
        var vectorX = MemoryMarshal.Cast<T, Vector<T>>(x);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Atan2(vectorY, vectorX[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vx = (stackalloc T[Vector<T>.Count]);
            x.Slice(vectorLength).CopyTo(vx);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Atan2(vectorY, Unsafe.As<T, Vector<T>>(ref vx[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

    /// <inheritdoc />
    protected internal override void Atan2Core<T>(ReadOnlySpan<T> y, T x, Span<T> ans)
    {
        var vectorY = MemoryMarshal.Cast<T, Vector<T>>(y);
        var vectorX = new Vector<T>(x);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Atan2(vectorY[i], vectorX);
        }
        if(vectorLength < ans.Length)
        {
            var vy = (stackalloc T[Vector<T>.Count]);
            y.Slice(vectorLength).CopyTo(vy);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Atan2(Unsafe.As<T, Vector<T>>(ref vy[0]), vectorX);
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

    /// <inheritdoc />
    protected internal override void Atan2Core<T>(ReadOnlySpan<T> y, ReadOnlySpan<T> x, Span<T> ans)
    {
        var vectorY = MemoryMarshal.Cast<T, Vector<T>>(y);
        var vectorX = MemoryMarshal.Cast<T, Vector<T>>(x);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Atan2(vectorY[i], vectorX[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vy = (stackalloc T[Vector<T>.Count]);
            var vx = (stackalloc T[Vector<T>.Count]);
            y.Slice(vectorLength).CopyTo(vy);
            x.Slice(vectorLength).CopyTo(vx);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Atan2(Unsafe.As<T, Vector<T>>(ref vy[0]), Unsafe.As<T, Vector<T>>(ref vx[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void PowCore<T>(T x, ReadOnlySpan<T> y, Span<T> ans)
    {
        var vectorX = new Vector<T>(x);
        var vectorY = MemoryMarshal.Cast<T, Vector<T>>(y);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Pow(vectorX, vectorY[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vy = (stackalloc T[Vector<T>.Count]);
            y.Slice(vectorLength).CopyTo(vy);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Pow(vectorX, Unsafe.As<T, Vector<T>>(ref vy[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

    /// <inheritdoc />
    protected internal override void PowCore<T>(ReadOnlySpan<T> x, T y, Span<T> ans)
    {
        var vectorX = MemoryMarshal.Cast<T, Vector<T>>(x);
        var vectorY = new Vector<T>(y);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Pow(vectorX[i], vectorY);
        }
        if(vectorLength < ans.Length)
        {
            var vx = (stackalloc T[Vector<T>.Count]);
            x.Slice(vectorLength).CopyTo(vx);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Pow(Unsafe.As<T, Vector<T>>(ref vx[0]), vectorY);
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

    /// <inheritdoc />
    protected internal override void PowCore<T>(ReadOnlySpan<T> x, ReadOnlySpan<T> y, Span<T> ans)
    {
        var vectorX = MemoryMarshal.Cast<T, Vector<T>>(x);
        var vectorY = MemoryMarshal.Cast<T, Vector<T>>(y);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Pow(vectorX[i], vectorY[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vx = (stackalloc T[Vector<T>.Count]);
            var vy = (stackalloc T[Vector<T>.Count]);
            x.Slice(vectorLength).CopyTo(vx);
            y.Slice(vectorLength).CopyTo(vy);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Pow(Unsafe.As<T, Vector<T>>(ref vx[0]), Unsafe.As<T, Vector<T>>(ref vy[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void LogCore<T>(T d, ReadOnlySpan<T> newBase, Span<T> ans)
    {
        var vectorD = new Vector<T>(d);
        var vectorNewBase = MemoryMarshal.Cast<T, Vector<T>>(newBase);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Log(vectorD, vectorNewBase[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vnewBase = (stackalloc T[Vector<T>.Count]);
            newBase.Slice(vectorLength).CopyTo(vnewBase);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Log(vectorD, Unsafe.As<T, Vector<T>>(ref vnewBase[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

    /// <inheritdoc />
    protected internal override void LogCore<T>(ReadOnlySpan<T> d, T newBase, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorNewBase = new Vector<T>(newBase);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Log(vectorD[i], vectorNewBase);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Log(Unsafe.As<T, Vector<T>>(ref vd[0]), vectorNewBase);
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

    /// <inheritdoc />
    protected internal override void LogCore<T>(ReadOnlySpan<T> d, ReadOnlySpan<T> newBase, Span<T> ans)
    {
        var vectorD = MemoryMarshal.Cast<T, Vector<T>>(d);
        var vectorNewBase = MemoryMarshal.Cast<T, Vector<T>>(newBase);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Log(vectorD[i], vectorNewBase[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vd = (stackalloc T[Vector<T>.Count]);
            var vnewBase = (stackalloc T[Vector<T>.Count]);
            d.Slice(vectorLength).CopyTo(vd);
            newBase.Slice(vectorLength).CopyTo(vnewBase);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Log(Unsafe.As<T, Vector<T>>(ref vd[0]), Unsafe.As<T, Vector<T>>(ref vnewBase[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }


    /// <inheritdoc />
    protected internal override void ScaleCore<T>(T n, ReadOnlySpan<T> x, Span<T> ans)
    {
        var vectorN = new Vector<T>(n);
        var vectorX = MemoryMarshal.Cast<T, Vector<T>>(x);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Scale(vectorN, vectorX[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vx = (stackalloc T[Vector<T>.Count]);
            x.Slice(vectorLength).CopyTo(vx);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Scale(vectorN, Unsafe.As<T, Vector<T>>(ref vx[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

    /// <inheritdoc />
    protected internal override void ScaleCore<T>(ReadOnlySpan<T> n, T x, Span<T> ans)
    {
        var vectorN = MemoryMarshal.Cast<T, Vector<T>>(n);
        var vectorX = new Vector<T>(x);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Scale(vectorN[i], vectorX);
        }
        if(vectorLength < ans.Length)
        {
            var vn = (stackalloc T[Vector<T>.Count]);
            n.Slice(vectorLength).CopyTo(vn);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Scale(Unsafe.As<T, Vector<T>>(ref vn[0]), vectorX);
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

    /// <inheritdoc />
    protected internal override void ScaleCore<T>(ReadOnlySpan<T> n, ReadOnlySpan<T> x, Span<T> ans)
    {
        var vectorN = MemoryMarshal.Cast<T, Vector<T>>(n);
        var vectorX = MemoryMarshal.Cast<T, Vector<T>>(x);
        var vectorAns = MemoryMarshal.Cast<T, Vector<T>>(ans);
        var vectorLength = vectorAns.Length * Vector<T>.Count;
        for(var i = 0; i < vectorAns.Length; ++i)
        {
            vectorAns[i] = VectorMath.Scale(vectorN[i], vectorX[i]);
        }
        if(vectorLength < ans.Length)
        {
            var vn = (stackalloc T[Vector<T>.Count]);
            var vx = (stackalloc T[Vector<T>.Count]);
            n.Slice(vectorLength).CopyTo(vn);
            x.Slice(vectorLength).CopyTo(vx);
            var vans = (stackalloc T[Vector<T>.Count]);
            Unsafe.As<T, Vector<T>>(ref vans[0]) = VectorMath.Scale(Unsafe.As<T, Vector<T>>(ref vn[0]), Unsafe.As<T, Vector<T>>(ref vx[0]));
            vans.Slice(0, ans.Length - vectorLength).CopyTo(ans.Slice(vectorLength));
        }
    }

}


