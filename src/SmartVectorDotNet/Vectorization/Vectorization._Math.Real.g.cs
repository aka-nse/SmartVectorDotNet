// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace SmartVectorDotNet;

partial class Vectorization
{

    /// <summary>
    /// Operates sqrt.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Sqrt<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        SqrtCore(d, ans);
    }

    /// <summary>
    /// Core implementation for sqrt.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void SqrtCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Sqrt(d[i]);
    }


    /// <summary>
    /// Operates cos.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Cos<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        CosCore(d, ans);
    }

    /// <summary>
    /// Core implementation for cos.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void CosCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Cos(d[i]);
    }


    /// <summary>
    /// Operates sin.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Sin<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        SinCore(d, ans);
    }

    /// <summary>
    /// Core implementation for sin.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void SinCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Sin(d[i]);
    }


    /// <summary>
    /// Operates tan.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Tan<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        TanCore(d, ans);
    }

    /// <summary>
    /// Core implementation for tan.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void TanCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Tan(d[i]);
    }


    /// <summary>
    /// Operates cosh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Cosh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        CoshCore(d, ans);
    }

    /// <summary>
    /// Core implementation for cosh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void CoshCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Cosh(d[i]);
    }


    /// <summary>
    /// Operates sinh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Sinh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        SinhCore(d, ans);
    }

    /// <summary>
    /// Core implementation for sinh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void SinhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Sinh(d[i]);
    }


    /// <summary>
    /// Operates tanh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Tanh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        TanhCore(d, ans);
    }

    /// <summary>
    /// Core implementation for tanh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void TanhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Tanh(d[i]);
    }


    /// <summary>
    /// Operates acos.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Acos<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AcosCore(d, ans);
    }

    /// <summary>
    /// Core implementation for acos.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AcosCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Acos(d[i]);
    }


    /// <summary>
    /// Operates asin.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Asin<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AsinCore(d, ans);
    }

    /// <summary>
    /// Core implementation for asin.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AsinCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Asin(d[i]);
    }


    /// <summary>
    /// Operates atan.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atan<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AtanCore(d, ans);
    }

    /// <summary>
    /// Core implementation for atan.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AtanCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atan(d[i]);
    }


    /// <summary>
    /// Operates acosh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Acosh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AcoshCore(d, ans);
    }

    /// <summary>
    /// Core implementation for acosh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AcoshCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Acosh(d[i]);
    }


    /// <summary>
    /// Operates asinh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Asinh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AsinhCore(d, ans);
    }

    /// <summary>
    /// Core implementation for asinh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AsinhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Asinh(d[i]);
    }


    /// <summary>
    /// Operates atanh.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atanh<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        AtanhCore(d, ans);
    }

    /// <summary>
    /// Core implementation for atanh.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void AtanhCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atanh(d[i]);
    }


    /// <summary>
    /// Operates cbrt.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Cbrt<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        CbrtCore(d, ans);
    }

    /// <summary>
    /// Core implementation for cbrt.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void CbrtCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Cbrt(d[i]);
    }


    /// <summary>
    /// Operates log2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log2<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        Log2Core(d, ans);
    }

    /// <summary>
    /// Core implementation for log2.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Log2Core<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log2(d[i]);
    }


    /// <summary>
    /// Operates ceiling.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Ceiling<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        CeilingCore(d, ans);
    }

    /// <summary>
    /// Core implementation for ceiling.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void CeilingCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Ceiling(d[i]);
    }


    /// <summary>
    /// Operates floor.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Floor<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        FloorCore(d, ans);
    }

    /// <summary>
    /// Core implementation for floor.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void FloorCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Floor(d[i]);
    }


    /// <summary>
    /// Operates exp.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Exp<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        ExpCore(d, ans);
    }

    /// <summary>
    /// Core implementation for exp.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void ExpCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Exp(d[i]);
    }


    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        LogCore(d, ans);
    }

    /// <summary>
    /// Core implementation for log.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void LogCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log(d[i]);
    }


    /// <summary>
    /// Operates log10.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log10<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        Log10Core(d, ans);
    }

    /// <summary>
    /// Core implementation for log10.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Log10Core<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log10(d[i]);
    }


    /// <summary>
    /// Operates round.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Round<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        RoundCore(d, ans);
    }

    /// <summary>
    /// Core implementation for round.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void RoundCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Round(d[i]);
    }


    /// <summary>
    /// Operates truncate.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Truncate<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        TruncateCore(d, ans);
    }

    /// <summary>
    /// Core implementation for truncate.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void TruncateCore<T>(ReadOnlySpan<T> d, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Truncate(d[i]);
    }




    /// <summary>
    /// Operates atan2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atan2<T>(T y, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        Atan2Core(y, x, ans);
    }

    /// <summary>
    /// Operates atan2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atan2<T>(ReadOnlySpan<T> y, T x, Span<T> ans)
        where T : unmanaged
    {
        if(y.Length != ans.Length) throw new ArgumentException(nameof(y));
        Atan2Core(y, x, ans);
    }

    /// <summary>
    /// Operates atan2.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Atan2<T>(ReadOnlySpan<T> y, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        if(y.Length != ans.Length) throw new ArgumentException(nameof(y));
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        Atan2Core(y, x, ans);
    }

    /// <summary>
    /// Core implementation for atan2.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Atan2Core<T>(T y, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atan2(y, x[i]);
    }

    /// <summary>
    /// Core implementation for atan2.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Atan2Core<T>(ReadOnlySpan<T> y, T x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atan2(y[i], x);
    }

    /// <summary>
    /// Core implementation for atan2.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="y"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void Atan2Core<T>(ReadOnlySpan<T> y, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Atan2(y[i], x[i]);
    }


    /// <summary>
    /// Operates pow.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Pow<T>(T x, ReadOnlySpan<T> y, Span<T> ans)
        where T : unmanaged
    {
        if(y.Length != ans.Length) throw new ArgumentException(nameof(y));
        PowCore(x, y, ans);
    }

    /// <summary>
    /// Operates pow.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Pow<T>(ReadOnlySpan<T> x, T y, Span<T> ans)
        where T : unmanaged
    {
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        PowCore(x, y, ans);
    }

    /// <summary>
    /// Operates pow.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Pow<T>(ReadOnlySpan<T> x, ReadOnlySpan<T> y, Span<T> ans)
        where T : unmanaged
    {
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        if(y.Length != ans.Length) throw new ArgumentException(nameof(y));
        PowCore(x, y, ans);
    }

    /// <summary>
    /// Core implementation for pow.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void PowCore<T>(T x, ReadOnlySpan<T> y, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Pow(x, y[i]);
    }

    /// <summary>
    /// Core implementation for pow.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void PowCore<T>(ReadOnlySpan<T> x, T y, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Pow(x[i], y);
    }

    /// <summary>
    /// Core implementation for pow.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void PowCore<T>(ReadOnlySpan<T> x, ReadOnlySpan<T> y, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Pow(x[i], y[i]);
    }


    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log<T>(T d, ReadOnlySpan<T> newBase, Span<T> ans)
        where T : unmanaged
    {
        if(newBase.Length != ans.Length) throw new ArgumentException(nameof(newBase));
        LogCore(d, newBase, ans);
    }

    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log<T>(ReadOnlySpan<T> d, T newBase, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        LogCore(d, newBase, ans);
    }

    /// <summary>
    /// Operates log.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Log<T>(ReadOnlySpan<T> d, ReadOnlySpan<T> newBase, Span<T> ans)
        where T : unmanaged
    {
        if(d.Length != ans.Length) throw new ArgumentException(nameof(d));
        if(newBase.Length != ans.Length) throw new ArgumentException(nameof(newBase));
        LogCore(d, newBase, ans);
    }

    /// <summary>
    /// Core implementation for log.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void LogCore<T>(T d, ReadOnlySpan<T> newBase, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log(d, newBase[i]);
    }

    /// <summary>
    /// Core implementation for log.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void LogCore<T>(ReadOnlySpan<T> d, T newBase, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log(d[i], newBase);
    }

    /// <summary>
    /// Core implementation for log.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="d"></param>
    /// <param name="newBase"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void LogCore<T>(ReadOnlySpan<T> d, ReadOnlySpan<T> newBase, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Log(d[i], newBase[i]);
    }


    /// <summary>
    /// Operates scale.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Scale<T>(T n, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        ScaleCore(n, x, ans);
    }

    /// <summary>
    /// Operates scale.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Scale<T>(ReadOnlySpan<T> n, T x, Span<T> ans)
        where T : unmanaged
    {
        if(n.Length != ans.Length) throw new ArgumentException(nameof(n));
        ScaleCore(n, x, ans);
    }

    /// <summary>
    /// Operates scale.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public void Scale<T>(ReadOnlySpan<T> n, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        if(n.Length != ans.Length) throw new ArgumentException(nameof(n));
        if(x.Length != ans.Length) throw new ArgumentException(nameof(x));
        ScaleCore(n, x, ans);
    }

    /// <summary>
    /// Core implementation for scale.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void ScaleCore<T>(T n, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Scale(n, x[i]);
    }

    /// <summary>
    /// Core implementation for scale.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void ScaleCore<T>(ReadOnlySpan<T> n, T x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Scale(n[i], x);
    }

    /// <summary>
    /// Core implementation for scale.
    /// For this method it is ensured that all parameters have same length.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="n"></param>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <returns></returns>
    protected internal virtual void ScaleCore<T>(ReadOnlySpan<T> n, ReadOnlySpan<T> x, Span<T> ans)
        where T : unmanaged
    {
        for(var i = 0; i < ans.Length; ++i)
            ans[i] = ScalarMath.Scale(n[i], x[i]);
    }

}


partial class SimdVectorization
{

}


