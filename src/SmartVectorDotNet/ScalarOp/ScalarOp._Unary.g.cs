// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Runtime.CompilerServices;
namespace SmartVectorDotNet;
using H = InternalHelpers;

partial class ScalarOp
{

    /// <summary> Operates <c>UnaryPlus</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T UnaryPlus<T>(in T x)
        where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<sbyte , T>((sbyte )(+Reinterpret<T, sbyte >(x)));
        if(typeof(T) == typeof(ushort)) return Reinterpret<short , T>((short )(+Reinterpret<T, short >(x)));
        if(typeof(T) == typeof(uint  )) return Reinterpret<int   , T>((int   )(+Reinterpret<T, int   >(x)));
        if(typeof(T) == typeof(ulong )) return Reinterpret<long  , T>((long  )(+Reinterpret<T, long  >(x)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nint  , T>((nint  )(+Reinterpret<T, nint  >(x)));
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(+Reinterpret<T, sbyte >(x)));
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(+Reinterpret<T, short >(x)));
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(+Reinterpret<T, int   >(x)));
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(+Reinterpret<T, long  >(x)));
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(+Reinterpret<T, nint  >(x)));
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(+Reinterpret<T, float >(x)));
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(+Reinterpret<T, double>(x)));
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>UnaryMinus</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T UnaryMinus<T>(in T x)
        where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<sbyte , T>((sbyte )(-Reinterpret<T, sbyte >(x)));
        if(typeof(T) == typeof(ushort)) return Reinterpret<short , T>((short )(-Reinterpret<T, short >(x)));
        if(typeof(T) == typeof(uint  )) return Reinterpret<int   , T>((int   )(-Reinterpret<T, int   >(x)));
        if(typeof(T) == typeof(ulong )) return Reinterpret<long  , T>((long  )(-Reinterpret<T, long  >(x)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nint  , T>((nint  )(-Reinterpret<T, nint  >(x)));
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(-Reinterpret<T, sbyte >(x)));
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(-Reinterpret<T, short >(x)));
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(-Reinterpret<T, int   >(x)));
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(-Reinterpret<T, long  >(x)));
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(-Reinterpret<T, nint  >(x)));
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(-Reinterpret<T, float >(x)));
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(-Reinterpret<T, double>(x)));
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>Not</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Not<T>(in T x)
        where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) throw new NotSupportedException();
        if(typeof(T) == typeof(ushort)) throw new NotSupportedException();
        if(typeof(T) == typeof(uint  )) throw new NotSupportedException();
        if(typeof(T) == typeof(ulong )) throw new NotSupportedException();
        if(typeof(T) == typeof(nuint )) throw new NotSupportedException();
        if(typeof(T) == typeof(sbyte )) throw new NotSupportedException();
        if(typeof(T) == typeof(short )) throw new NotSupportedException();
        if(typeof(T) == typeof(int   )) throw new NotSupportedException();
        if(typeof(T) == typeof(long  )) throw new NotSupportedException();
        if(typeof(T) == typeof(nint  )) throw new NotSupportedException();
        if(typeof(T) == typeof(float )) throw new NotSupportedException();
        if(typeof(T) == typeof(double)) throw new NotSupportedException();
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>Complement</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Complement<T>(in T x)
        where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(~Reinterpret<T, byte  >(x)));
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(~Reinterpret<T, ushort>(x)));
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(~Reinterpret<T, uint  >(x)));
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(~Reinterpret<T, ulong >(x)));
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(~Reinterpret<T, nuint >(x)));
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(~Reinterpret<T, sbyte >(x)));
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(~Reinterpret<T, short >(x)));
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(~Reinterpret<T, int   >(x)));
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(~Reinterpret<T, long  >(x)));
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(~Reinterpret<T, nint  >(x)));
        if(typeof(T) == typeof(float )) return Reinterpret<uint  , T>((uint  )(~Reinterpret<T, uint  >(x)));
        if(typeof(T) == typeof(double)) return Reinterpret<ulong , T>((ulong )(~Reinterpret<T, ulong >(x)));
        throw new NotSupportedException();
    }

}
