// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Runtime.CompilerServices;
namespace SmartVectorDotNet;

partial class ScalarOp
{
    /// <summary> Compares 2 values of <typeparamref name="T"/>. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Equals<T>(in T x, in T y)
        where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<T, byte  >(x) == Reinterpret<T, byte  >(y);
        if(typeof(T) == typeof(ushort)) return Reinterpret<T, ushort>(x) == Reinterpret<T, ushort>(y);
        if(typeof(T) == typeof(uint  )) return Reinterpret<T, uint  >(x) == Reinterpret<T, uint  >(y);
        if(typeof(T) == typeof(ulong )) return Reinterpret<T, ulong >(x) == Reinterpret<T, ulong >(y);
        if(typeof(T) == typeof(nuint )) return Reinterpret<T, nuint >(x) == Reinterpret<T, nuint >(y);
        if(typeof(T) == typeof(sbyte )) return Reinterpret<T, sbyte >(x) == Reinterpret<T, sbyte >(y);
        if(typeof(T) == typeof(short )) return Reinterpret<T, short >(x) == Reinterpret<T, short >(y);
        if(typeof(T) == typeof(int   )) return Reinterpret<T, int   >(x) == Reinterpret<T, int   >(y);
        if(typeof(T) == typeof(long  )) return Reinterpret<T, long  >(x) == Reinterpret<T, long  >(y);
        if(typeof(T) == typeof(nint  )) return Reinterpret<T, nint  >(x) == Reinterpret<T, nint  >(y);
        if(typeof(T) == typeof(float )) return Reinterpret<T, float >(x) == Reinterpret<T, float >(y);
        if(typeof(T) == typeof(double)) return Reinterpret<T, double>(x) == Reinterpret<T, double>(y);
        throw new NotSupportedException();
    }


    /// <summary> Compares 2 values of <typeparamref name="T"/>. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Compare<T>(in T x, in T y)
        where T : unmanaged
    {
        if(typeof(T) == typeof(byte  ))
        {
            var xx = Unsafe.As<T, byte  >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, byte  >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(ushort))
        {
            var xx = Unsafe.As<T, ushort>(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, ushort>(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(uint  ))
        {
            var xx = Unsafe.As<T, uint  >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, uint  >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(ulong ))
        {
            var xx = Unsafe.As<T, ulong >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, ulong >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(nuint ))
        {
            var xx = Unsafe.As<T, nuint >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, nuint >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(sbyte ))
        {
            var xx = Unsafe.As<T, sbyte >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, sbyte >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(short ))
        {
            var xx = Unsafe.As<T, short >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, short >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(int   ))
        {
            var xx = Unsafe.As<T, int   >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, int   >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(long  ))
        {
            var xx = Unsafe.As<T, long  >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, long  >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(nint  ))
        {
            var xx = Unsafe.As<T, nint  >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, nint  >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(float ))
        {
            var xx = Unsafe.As<T, float >(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, float >(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        if(typeof(T) == typeof(double))
        {
            var xx = Unsafe.As<T, double>(ref Unsafe.AsRef(x));
            var yy = Unsafe.As<T, double>(ref Unsafe.AsRef(y));
            if(xx == yy) return 0;
            return xx > yy ? +1 : -1;
        }
        throw new NotSupportedException();
    }
}
