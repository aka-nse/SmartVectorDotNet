// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

using System.Runtime.CompilerServices;
namespace SmartVectorDotNet;

partial class ScalarOp
{

    /// <summary> Operates <c>Add</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Add<T>(in T x, in T y)
        where T : unmanaged
    {
        unchecked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) + Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) + Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) + Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) + Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(Reinterpret<T, nuint >(x) + Reinterpret<T, nuint >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) + Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) + Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) + Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) + Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(Reinterpret<T, nint  >(x) + Reinterpret<T, nint  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(Reinterpret<T, float >(x) + Reinterpret<T, float >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(Reinterpret<T, double>(x) + Reinterpret<T, double>(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>AddChecked</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T AddChecked<T>(in T x, in T y)
        where T : unmanaged
    {
        checked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) + Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) + Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) + Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) + Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(Reinterpret<T, nuint >(x) + Reinterpret<T, nuint >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) + Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) + Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) + Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) + Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(Reinterpret<T, nint  >(x) + Reinterpret<T, nint  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(Reinterpret<T, float >(x) + Reinterpret<T, float >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(Reinterpret<T, double>(x) + Reinterpret<T, double>(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>Subtract</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Subtract<T>(in T x, in T y)
        where T : unmanaged
    {
        unchecked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) - Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) - Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) - Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) - Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(Reinterpret<T, nuint >(x) - Reinterpret<T, nuint >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) - Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) - Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) - Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) - Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(Reinterpret<T, nint  >(x) - Reinterpret<T, nint  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(Reinterpret<T, float >(x) - Reinterpret<T, float >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(Reinterpret<T, double>(x) - Reinterpret<T, double>(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>SubtractChecked</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T SubtractChecked<T>(in T x, in T y)
        where T : unmanaged
    {
        checked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) - Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) - Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) - Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) - Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(Reinterpret<T, nuint >(x) - Reinterpret<T, nuint >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) - Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) - Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) - Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) - Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(Reinterpret<T, nint  >(x) - Reinterpret<T, nint  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(Reinterpret<T, float >(x) - Reinterpret<T, float >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(Reinterpret<T, double>(x) - Reinterpret<T, double>(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>Multiply</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Multiply<T>(in T x, in T y)
        where T : unmanaged
    {
        unchecked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) * Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) * Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) * Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) * Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(Reinterpret<T, nuint >(x) * Reinterpret<T, nuint >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) * Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) * Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) * Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) * Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(Reinterpret<T, nint  >(x) * Reinterpret<T, nint  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(Reinterpret<T, float >(x) * Reinterpret<T, float >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(Reinterpret<T, double>(x) * Reinterpret<T, double>(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>MultiplyChecked</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T MultiplyChecked<T>(in T x, in T y)
        where T : unmanaged
    {
        checked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) * Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) * Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) * Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) * Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(Reinterpret<T, nuint >(x) * Reinterpret<T, nuint >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) * Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) * Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) * Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) * Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(Reinterpret<T, nint  >(x) * Reinterpret<T, nint  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(Reinterpret<T, float >(x) * Reinterpret<T, float >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(Reinterpret<T, double>(x) * Reinterpret<T, double>(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>Divide</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Divide<T>(in T x, in T y)
        where T : unmanaged
    {
        unchecked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) / Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) / Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) / Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) / Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(Reinterpret<T, nuint >(x) / Reinterpret<T, nuint >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) / Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) / Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) / Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) / Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(Reinterpret<T, nint  >(x) / Reinterpret<T, nint  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(Reinterpret<T, float >(x) / Reinterpret<T, float >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(Reinterpret<T, double>(x) / Reinterpret<T, double>(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>Modulo</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Modulo<T>(in T x, in T y)
        where T : unmanaged
    {
        unchecked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) % Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) % Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) % Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) % Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>((nuint )(Reinterpret<T, nuint >(x) % Reinterpret<T, nuint >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) % Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) % Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) % Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) % Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>((nint  )(Reinterpret<T, nint  >(x) % Reinterpret<T, nint  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<float , T>((float )(Reinterpret<T, float >(x) % Reinterpret<T, float >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<double, T>((double)(Reinterpret<T, double>(x) % Reinterpret<T, double>(y)));
        }
        throw new NotSupportedException();
    }



    /// <summary> Operates <c>BitwiseOr</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T BitwiseOr<T>(in T x, in T y)
        where T : unmanaged
    {
        unchecked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) | Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) | Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) | Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) | Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) | Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) | Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) | Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) | Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) | Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) | Reinterpret<T, ulong >(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>BitwiseAnd</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T BitwiseAnd<T>(in T x, in T y)
        where T : unmanaged
    {
        unchecked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) & Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) & Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) & Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) & Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) & Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) & Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) & Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) & Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) & Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) & Reinterpret<T, ulong >(y)));
        }
        throw new NotSupportedException();
    }


    /// <summary> Operates <c>BitwiseXor</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T BitwiseXor<T>(in T x, in T y)
        where T : unmanaged
    {
        unchecked
        {
            if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>((byte  )(Reinterpret<T, byte  >(x) ^ Reinterpret<T, byte  >(y)));
            if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>((ushort)(Reinterpret<T, ushort>(x) ^ Reinterpret<T, ushort>(y)));
            if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) ^ Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) ^ Reinterpret<T, ulong >(y)));
            if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>((sbyte )(Reinterpret<T, sbyte >(x) ^ Reinterpret<T, sbyte >(y)));
            if(typeof(T) == typeof(short )) return Reinterpret<short , T>((short )(Reinterpret<T, short >(x) ^ Reinterpret<T, short >(y)));
            if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>((int   )(Reinterpret<T, int   >(x) ^ Reinterpret<T, int   >(y)));
            if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>((long  )(Reinterpret<T, long  >(x) ^ Reinterpret<T, long  >(y)));
            if(typeof(T) == typeof(float )) return Reinterpret<uint  , T>((uint  )(Reinterpret<T, uint  >(x) ^ Reinterpret<T, uint  >(y)));
            if(typeof(T) == typeof(double)) return Reinterpret<ulong , T>((ulong )(Reinterpret<T, ulong >(x) ^ Reinterpret<T, ulong >(y)));
        }
        throw new NotSupportedException();
    }

}
