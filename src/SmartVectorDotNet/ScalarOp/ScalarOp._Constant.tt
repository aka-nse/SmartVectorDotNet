<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var types = new [] {
    "byte  ",
    "ushort",
    "uint  ",
    "ulong ",
    "nuint ",
    "sbyte ",
    "short ",
    "int   ",
    "long  ",
    "nint  ",
    "float ",
    "double",
};
var intTypes = new [] {
    "byte     ",
    "ushort   ",
    "uint     ",
    "ulong    ",
    "nuint    ",
    "sbyte    ",
    "short    ",
    "int      ",
    "long     ",
    "nint     ",
};
var minMaxTypes = new [] {
    "byte  ",
    "ushort",
    "uint  ",
    "ulong ",
    "sbyte ",
    "short ",
    "int   ",
    "long  ",
    "float ",
    "double",
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Numerics;
using System.Runtime.CompilerServices;
namespace SmartVectorDotNet;
using H = InternalHelpers;

partial class ScalarOp
{
    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to <c>0</c>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T Zero<T>() where T : unmanaged
    {
<# foreach(var type in types) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(0);
<# } #>
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to <c>1</c>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T One<T>() where T : unmanaged
    {
<# foreach(var type in types) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(1);
<# } #>
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to <c>false</c> on SIMD operation.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T False<T>() where T : unmanaged
    {
<# foreach(var type in types) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(Constant.False_<#=type#>);
<# } #>
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to <c>true</c> on SIMD operation.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T True<T>() where T : unmanaged
    {
<# foreach(var type in types) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(Constant.True_<#=type#>);
<# } #>
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to minimum value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T MinValue<T>() where T : unmanaged
    {
<# foreach(var type in minMaxTypes) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(<#=type#>.MinValue);
<# } #>
        #if NET5_0_OR_GREATER
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(nuint .MinValue);
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(nint  .MinValue);
        #else
        if(typeof(T) == typeof(nuint ))
        {
            return Unsafe.SizeOf<nuint>() switch
            {
                sizeof(ulong) => Reinterpret<ulong, T>(ulong.MinValue),
                sizeof(uint ) => Reinterpret<uint , T>(uint .MinValue),
                _ => throw new NotSupportedException(),
            };
        }
        if(typeof(T) == typeof(nint  ))
        {
            return Unsafe.SizeOf<nint>() switch
            {
                sizeof(long) => Reinterpret<long, T>(long.MinValue),
                sizeof(int ) => Reinterpret<int , T>(int .MinValue),
                _ => throw new NotSupportedException(),
            };
        }
        #endif
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to maximum value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T MaxValue<T>() where T : unmanaged
    {
<# foreach(var type in minMaxTypes) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type#>, T>(<#=type#>.MaxValue);
<# } #>
        #if NET5_0_OR_GREATER
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(nuint .MaxValue);
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(nint  .MaxValue);
        #else
        if(typeof(T) == typeof(nuint ))
        {
            return Unsafe.SizeOf<nuint>() switch
            {
                sizeof(ulong) => Reinterpret<ulong, T>(ulong.MaxValue),
                sizeof(uint ) => Reinterpret<uint , T>(uint .MaxValue),
                _ => throw new NotSupportedException(),
            };
        }
        if(typeof(T) == typeof(nint  ))
        {
            return Unsafe.SizeOf<nint>() switch
            {
                sizeof(long) => Reinterpret<long, T>(long.MaxValue),
                sizeof(int ) => Reinterpret<int , T>(int .MaxValue),
                _ => throw new NotSupportedException(),
            };
        }
        #endif
        throw new NotSupportedException();
    }
}

file class Constant
{
<# foreach(var type in types) { #>
    public static readonly <#=type#> False_<#=type#> = VectorMath.Const<<#=type#>>.FalseValue[0];
    public static readonly <#=type#> True_<#=type#>  = VectorMath.Const<<#=type#>>.TrueValue [0];
<# } #>
}