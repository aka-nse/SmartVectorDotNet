<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var operations = new (string, Func<string, string>) [] {
    ("UnaryPlus" , x =>$"+{x}"),
    ("UnaryMinus", x =>$"-{x}"),
    ("Not"       , x =>$"!{x}"),
    ("Complement", x =>$"~{x}"),
};
var types = new TypeDef [] {
//              type      +x        -x        !x    ~x
    new TypeDef("byte"  , "sbyte" , "sbyte" , null, "byte"  ),
    new TypeDef("ushort", "short" , "short" , null, "ushort"),
    new TypeDef("uint"  , "int"   , "int"   , null, "uint"  ),
    new TypeDef("ulong" , "long"  , "long"  , null, "ulong" ),
    new TypeDef("nuint" , "nint"  , "nint"  , null, "nuint" ),
    new TypeDef("sbyte" , "sbyte" , "sbyte" , null, "sbyte" ),
    new TypeDef("short" , "short" , "short" , null, "short" ),
    new TypeDef("int"   , "int"   , "int"   , null, "int"   ),
    new TypeDef("long"  , "long"  , "long"  , null, "long"  ),
    new TypeDef("nint"  , "nint"  , "nint"  , null, "nint"  ),
    new TypeDef("float" , "float" , "float" , null, "uint"  ),
    new TypeDef("double", "double", "double", null, "ulong" ),
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Runtime.CompilerServices;
namespace SmartVectorDotNet;
using H = InternalHelpers;

partial class ScalarOp
{
<# foreach(var (opname, op) in operations) { #>

    /// <summary> Operates <c><#=opname#></c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T <#=opname#><T>(in T x)
        where T : unmanaged
    {
<# foreach(var type in types) { #>
<#     if(type.OperationType[opname] is not null) { #>
        if(typeof(T) == typeof(<#=type#>)) return Reinterpret<<#=type.OperationType[opname]#>, T>((<#=type.OperationType[opname]#>)(<#=op($"Reinterpret<T, {type.OperationType[opname]}>(x)")#>));
<#     } else { #>
        if(typeof(T) == typeof(<#=type#>)) throw new NotSupportedException();
<#     } #>
<# } #>
        throw new NotSupportedException();
    }

<# } #>
}
<#+
public class TypeDef
{
    public string Name { get; }
    public Dictionary<string, string> OperationType { get; }

    public TypeDef(string name, string unaryPlus, string unaryMinus, string not, string complement)
    {
        Name          = name      ;
        OperationType = new Dictionary<string, string>
        {
            { "UnaryPlus" , unaryPlus  is not null ? $"{unaryPlus , -6}" : null },
            { "UnaryMinus", unaryMinus is not null ? $"{unaryMinus, -6}" : null },
            { "Not"       , not        is not null ? $"{not       , -6}" : null },
            { "Complement", complement is not null ? $"{complement, -6}" : null },
        };
    }

    public override string ToString() => $"{Name, -6}";
}
#>