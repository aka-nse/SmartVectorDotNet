// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Numerics;
using System.Runtime.CompilerServices;
namespace SmartVectorDotNet;
using H = InternalHelpers;

partial class ScalarOp
{
    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to <c>0</c>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T Zero<T>() where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(0);
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(0);
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(0);
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(0);
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(0);
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(0);
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(0);
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(0);
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(0);
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(0);
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(0);
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(0);
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to <c>1</c>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T One<T>() where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(1);
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(1);
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(1);
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(1);
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(1);
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(1);
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(1);
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(1);
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(1);
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(1);
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(1);
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(1);
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to <c>false</c> on SIMD operation.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T False<T>() where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(Constant.False_byte  );
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(Constant.False_ushort);
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(Constant.False_uint  );
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(Constant.False_ulong );
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(Constant.False_nuint );
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(Constant.False_sbyte );
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(Constant.False_short );
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(Constant.False_int   );
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(Constant.False_long  );
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Constant.False_nint  );
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(Constant.False_float );
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(Constant.False_double);
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to <c>true</c> on SIMD operation.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T True<T>() where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(Constant.True_byte  );
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(Constant.True_ushort);
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(Constant.True_uint  );
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(Constant.True_ulong );
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(Constant.True_nuint );
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(Constant.True_sbyte );
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(Constant.True_short );
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(Constant.True_int   );
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(Constant.True_long  );
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(Constant.True_nint  );
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(Constant.True_float );
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(Constant.True_double);
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to minimum value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T MinValue<T>() where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(byte  .MinValue);
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(ushort.MinValue);
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(uint  .MinValue);
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(ulong .MinValue);
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(sbyte .MinValue);
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(short .MinValue);
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(int   .MinValue);
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(long  .MinValue);
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(float .MinValue);
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(double.MinValue);
        #if NET5_0_OR_GREATER
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(nuint .MinValue);
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(nint  .MinValue);
        #else
        if(typeof(T) == typeof(nuint ))
        {
            return Unsafe.SizeOf<nuint>() switch
            {
                sizeof(ulong) => Reinterpret<ulong, T>(ulong.MinValue),
                sizeof(uint ) => Reinterpret<uint , T>(uint .MinValue),
                _ => throw new NotSupportedException(),
            };
        }
        if(typeof(T) == typeof(nint  ))
        {
            return Unsafe.SizeOf<nint>() switch
            {
                sizeof(long) => Reinterpret<long, T>(long.MinValue),
                sizeof(int ) => Reinterpret<int , T>(int .MinValue),
                _ => throw new NotSupportedException(),
            };
        }
        #endif
        throw new NotSupportedException();
    }


    /// <summary>
    /// Gets a value of <typeparamref name="T"/> which is corresponding to maximum value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <returns></returns>
    public static T MaxValue<T>() where T : unmanaged
    {
        if(typeof(T) == typeof(byte  )) return Reinterpret<byte  , T>(byte  .MaxValue);
        if(typeof(T) == typeof(ushort)) return Reinterpret<ushort, T>(ushort.MaxValue);
        if(typeof(T) == typeof(uint  )) return Reinterpret<uint  , T>(uint  .MaxValue);
        if(typeof(T) == typeof(ulong )) return Reinterpret<ulong , T>(ulong .MaxValue);
        if(typeof(T) == typeof(sbyte )) return Reinterpret<sbyte , T>(sbyte .MaxValue);
        if(typeof(T) == typeof(short )) return Reinterpret<short , T>(short .MaxValue);
        if(typeof(T) == typeof(int   )) return Reinterpret<int   , T>(int   .MaxValue);
        if(typeof(T) == typeof(long  )) return Reinterpret<long  , T>(long  .MaxValue);
        if(typeof(T) == typeof(float )) return Reinterpret<float , T>(float .MaxValue);
        if(typeof(T) == typeof(double)) return Reinterpret<double, T>(double.MaxValue);
        #if NET5_0_OR_GREATER
        if(typeof(T) == typeof(nuint )) return Reinterpret<nuint , T>(nuint .MaxValue);
        if(typeof(T) == typeof(nint  )) return Reinterpret<nint  , T>(nint  .MaxValue);
        #else
        if(typeof(T) == typeof(nuint ))
        {
            return Unsafe.SizeOf<nuint>() switch
            {
                sizeof(ulong) => Reinterpret<ulong, T>(ulong.MaxValue),
                sizeof(uint ) => Reinterpret<uint , T>(uint .MaxValue),
                _ => throw new NotSupportedException(),
            };
        }
        if(typeof(T) == typeof(nint  ))
        {
            return Unsafe.SizeOf<nint>() switch
            {
                sizeof(long) => Reinterpret<long, T>(long.MaxValue),
                sizeof(int ) => Reinterpret<int , T>(int .MaxValue),
                _ => throw new NotSupportedException(),
            };
        }
        #endif
        throw new NotSupportedException();
    }
}

file class Constant
{
    public static readonly byte   False_byte   = VectorMath.Const<byte  >.FalseValue[0];
    public static readonly byte   True_byte    = VectorMath.Const<byte  >.TrueValue [0];
    public static readonly ushort False_ushort = VectorMath.Const<ushort>.FalseValue[0];
    public static readonly ushort True_ushort  = VectorMath.Const<ushort>.TrueValue [0];
    public static readonly uint   False_uint   = VectorMath.Const<uint  >.FalseValue[0];
    public static readonly uint   True_uint    = VectorMath.Const<uint  >.TrueValue [0];
    public static readonly ulong  False_ulong  = VectorMath.Const<ulong >.FalseValue[0];
    public static readonly ulong  True_ulong   = VectorMath.Const<ulong >.TrueValue [0];
    public static readonly nuint  False_nuint  = VectorMath.Const<nuint >.FalseValue[0];
    public static readonly nuint  True_nuint   = VectorMath.Const<nuint >.TrueValue [0];
    public static readonly sbyte  False_sbyte  = VectorMath.Const<sbyte >.FalseValue[0];
    public static readonly sbyte  True_sbyte   = VectorMath.Const<sbyte >.TrueValue [0];
    public static readonly short  False_short  = VectorMath.Const<short >.FalseValue[0];
    public static readonly short  True_short   = VectorMath.Const<short >.TrueValue [0];
    public static readonly int    False_int    = VectorMath.Const<int   >.FalseValue[0];
    public static readonly int    True_int     = VectorMath.Const<int   >.TrueValue [0];
    public static readonly long   False_long   = VectorMath.Const<long  >.FalseValue[0];
    public static readonly long   True_long    = VectorMath.Const<long  >.TrueValue [0];
    public static readonly nint   False_nint   = VectorMath.Const<nint  >.FalseValue[0];
    public static readonly nint   True_nint    = VectorMath.Const<nint  >.TrueValue [0];
    public static readonly float  False_float  = VectorMath.Const<float >.FalseValue[0];
    public static readonly float  True_float   = VectorMath.Const<float >.TrueValue [0];
    public static readonly double False_double = VectorMath.Const<double>.FalseValue[0];
    public static readonly double True_double  = VectorMath.Const<double>.TrueValue [0];
}