<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var types = new TypeDef[]
{
    new("byte"  , "Byte"   , false),
    new("ushort", "UInt16" , false),
    new("uint"  , "UInt32" , false),
    new("ulong" , "UInt64" , false),
    new("nuint" , "UIntPtr", false),
    new("sbyte" , "SByte"  , true),
    new("short" , "Int16"  , true),
    new("int"   , "Int32"  , true),
    new("long"  , "Int64"  , true),
    new("nint"  , "IntPtr" , true),
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
#if NETCOREAPP3_0_OR_GREATER
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
#endif
using System.Text;
using NVector = System.Numerics.Vector;
using H = SmartVectorDotNet.InternalHelpers;

using Xunit;

namespace SmartVectorDotNet;

public partial class VectorOpTest
{
<#  foreach(var type in types) { #>

    public static IEnumerable<object[]> <#=type.LongName#>TestCases()
    {
        static object[] core(<#=type.ShortName#>[] valueArray, byte[] shiftCountArray)
            => new object[] { valueArray, shiftCountArray };

        var valueArray = new [] {(<#=type.ShortName#>)0}.Concat(Enumerable.Repeat((<#=type.ShortName#>)1, 256)).ToArray();
        var shiftCountArray = new [] {(byte)0}.Concat(Enumerable.Range(0, 256).Select(x => (byte)x)).ToArray();
        yield return core(valueArray, shiftCountArray);
    }

    [Theory, MemberData(nameof(<#=type.LongName#>TestCases))]
    public void ShiftLeft_<#=type.LongName#>(<#=type.ShortName#>[] valueArray, byte[] shiftCountArray)
    {
        foreach(var (value, shiftCount) in valueArray.Zip(shiftCountArray))
        {
            var vvalue = new Vector<<#=type.ShortName#>>(value);
            var vshiftCount = new Vector<<#=type.ShortName#>>((<#=type.ShortName#>)shiftCount);
            AssertEx.Equal(VectorOp.ShiftLeftFallback(vvalue, shiftCount )[0], VectorOp.ShiftLeft<<#=type.ShortName#>>(vvalue, shiftCount )[0], $"shiftCount = {shiftCount}");
            AssertEx.Equal(VectorOp.ShiftLeftFallback(vvalue, vshiftCount)[0], VectorOp.ShiftLeft<<#=type.ShortName#>>(vvalue, vshiftCount)[0], $"shiftCount = {shiftCount}");
        }
    }

    [Theory, MemberData(nameof(<#=type.LongName#>TestCases))]
    public void ShiftRightLogical_<#=type.LongName#>(<#=type.ShortName#>[] valueArray, byte[] shiftCountArray)
    {
        foreach(var (value, shiftCount) in valueArray.Zip(shiftCountArray))
        {
            var vvalue = new Vector<<#=type.ShortName#>>(value);
            var vshiftCount = new Vector<<#=type.ShortName#>>((<#=type.ShortName#>)shiftCount);
            AssertEx.Equal(VectorOp.ShiftRightLogicalFallback(vvalue, shiftCount )[0], VectorOp.ShiftRightLogical<<#=type.ShortName#>>(vvalue, shiftCount )[0], $"shiftCount = {shiftCount}");
            AssertEx.Equal(VectorOp.ShiftRightLogicalFallback(vvalue, vshiftCount)[0], VectorOp.ShiftRightLogical<<#=type.ShortName#>>(vvalue, vshiftCount)[0], $"shiftCount = {shiftCount}");
        }
    }

<#      if(type.IsSigned){ #>
    [Theory, MemberData(nameof(<#=type.LongName#>TestCases))]
    public void ShiftRightArithmetic_<#=type.LongName#>(<#=type.ShortName#>[] valueArray, byte[] shiftCountArray)
    {
        foreach(var (value, shiftCount) in valueArray.Zip(shiftCountArray))
        {
            var vvalue = new Vector<<#=type.ShortName#>>(value);
            var vshiftCount = new Vector<<#=type.ShortName#>>((<#=type.ShortName#>)shiftCount);
            AssertEx.Equal(VectorOp.ShiftRightArithmeticFallback(vvalue, shiftCount )[0], VectorOp.ShiftRightLogical<<#=type.ShortName#>>(vvalue, shiftCount )[0], $"shiftCount = {shiftCount}");
            AssertEx.Equal(VectorOp.ShiftRightArithmeticFallback(vvalue, vshiftCount)[0], VectorOp.ShiftRightLogical<<#=type.ShortName#>>(vvalue, vshiftCount)[0], $"shiftCount = {shiftCount}");
        }
    }
<#      } #>

<#  } #>
}

<#+

public class TypeDef
{
    public string ShortName { get; }
    public string LongName { get; }
    public bool IsSigned { get; }

    public TypeDef(string shortName, string longName, bool isSigned)
    {
        ShortName = shortName;
        LongName = longName;
        IsSigned = isSigned;
    }
}

#>