<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
const int maxNumberOfMembers = 20;
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;

namespace SmartVectorBenchmarks;

partial class TrigonometricBenchmarkContext
{
    public IReadOnlyDictionary<string, double> EvaluateErrors()
    {
        var retval = new Dictionary<string, double>();
        var sinEmulated = Use_Sin_Emulated();
        var cosEmulated = Use_Cos_Emulated();
<#  for(var i = 1; i < maxNumberOfMembers; ++i) { #>
        retval["Sin_<#=i#>"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_<#=i#>());
        retval["Cos_<#=i#>"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_<#=i#>());
<#  } #>
        return retval;
    }

<#  for(var i = 1; i < maxNumberOfMembers; ++i) { #>
    [Benchmark]
    public double[] Use_Sin_<#=i#>()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_<#=i#>(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_<#=i#>(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[<#=i#>];
<#      for(var j = i - 1; j >= 0; --j) { #>
        y = x2 * SinDenom[<#=j#>] * (Vector<double>.One - y);
<#      } #>
        return x * (Vector<double>.One - y);
    }
    
<#  } #>
<#  for(var i = 1; i < maxNumberOfMembers; ++i) { #>

    [Benchmark]
    public double[] Use_Cos_<#=i#>()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_<#=i#>(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_<#=i#>(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[<#=i#>];
<#      for(var j = i - 1; j >= 0; --j) { #>
        y = x2 * CosDenom[<#=j#>] * (Vector<double>.One - y);
<#      } #>
        return Vector<double>.One - y;
    }


<#  } #>
}