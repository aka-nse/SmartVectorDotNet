<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
const int maxNumberOfMembers = 19;
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using BenchmarkDotNet.Attributes;

namespace SmartVectorBenchmarks;

public partial class ExponentialBenchmarkContext
{
    public IReadOnlyDictionary<string, double> EvaluateErrors()
    {
        var retval = new Dictionary<string, double>();
        var expEmulated = Use_Exp_Emulated();
<#  for(var i = 1; i <= maxNumberOfMembers; ++i) { #>
        retval["Exp_<#=i#>"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_<#=i#>());
<#  } #>
        return retval;
    }

<#  for(var i = 1; i <= maxNumberOfMembers; ++i) { #>

    [Benchmark]
    public double[] Use_Exp_<#=i#>()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_<#=i#>(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_<#=i#>(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
<#      for(var j = i - 1; j >= 0; --j) { #>
        z = (b * ExpDenom[<#=j#>]) * (Vector<double>.One + z);
<#      } #>
        z = z + Vector<double>.One;
        return Scale(n, z);
    }

<#  } #>
}