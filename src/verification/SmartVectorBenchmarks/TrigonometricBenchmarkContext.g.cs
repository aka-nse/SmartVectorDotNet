// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;

namespace SmartVectorBenchmarks;

partial class TrigonometricBenchmarkContext
{
    public IReadOnlyDictionary<string, double> EvaluateErrors()
    {
        var retval = new Dictionary<string, double>();
        var sinEmulated = Use_Sin_Emulated();
        var cosEmulated = Use_Cos_Emulated();
        retval["Sin_1"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_1());
        retval["Cos_1"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_1());
        retval["Sin_2"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_2());
        retval["Cos_2"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_2());
        retval["Sin_3"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_3());
        retval["Cos_3"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_3());
        retval["Sin_4"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_4());
        retval["Cos_4"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_4());
        retval["Sin_5"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_5());
        retval["Cos_5"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_5());
        retval["Sin_6"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_6());
        retval["Cos_6"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_6());
        retval["Sin_7"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_7());
        retval["Cos_7"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_7());
        retval["Sin_8"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_8());
        retval["Cos_8"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_8());
        retval["Sin_9"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_9());
        retval["Cos_9"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_9());
        retval["Sin_10"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_10());
        retval["Cos_10"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_10());
        retval["Sin_11"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_11());
        retval["Cos_11"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_11());
        retval["Sin_12"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_12());
        retval["Cos_12"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_12());
        retval["Sin_13"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_13());
        retval["Cos_13"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_13());
        retval["Sin_14"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_14());
        retval["Cos_14"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_14());
        retval["Sin_15"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_15());
        retval["Cos_15"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_15());
        retval["Sin_16"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_16());
        retval["Cos_16"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_16());
        retval["Sin_17"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_17());
        retval["Cos_17"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_17());
        retval["Sin_18"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_18());
        retval["Cos_18"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_18());
        retval["Sin_19"] = BenchmarkHelper.CalculateErrorAbsolute(sinEmulated, Use_Sin_19());
        retval["Cos_19"] = BenchmarkHelper.CalculateErrorAbsolute(cosEmulated, Use_Cos_19());
        return retval;
    }

    [Benchmark]
    public double[] Use_Sin_1()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_1(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_1(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[1];
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_2()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_2(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_2(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[2];
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_3()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_3(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_3(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[3];
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_4()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_4(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_4(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[4];
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_5()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_5(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_5(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[5];
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_6()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_6(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_6(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[6];
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_7()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_7(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_7(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[7];
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_8()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_8(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_8(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[8];
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_9()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_9(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_9(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[9];
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_10()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_10(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_10(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[10];
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_11()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_11(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_11(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[11];
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_12()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_12(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_12(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[12];
        y = x2 * SinDenom[11] * (Vector<double>.One - y);
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_13()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_13(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_13(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[13];
        y = x2 * SinDenom[12] * (Vector<double>.One - y);
        y = x2 * SinDenom[11] * (Vector<double>.One - y);
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_14()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_14(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_14(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[14];
        y = x2 * SinDenom[13] * (Vector<double>.One - y);
        y = x2 * SinDenom[12] * (Vector<double>.One - y);
        y = x2 * SinDenom[11] * (Vector<double>.One - y);
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_15()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_15(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_15(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[15];
        y = x2 * SinDenom[14] * (Vector<double>.One - y);
        y = x2 * SinDenom[13] * (Vector<double>.One - y);
        y = x2 * SinDenom[12] * (Vector<double>.One - y);
        y = x2 * SinDenom[11] * (Vector<double>.One - y);
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_16()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_16(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_16(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[16];
        y = x2 * SinDenom[15] * (Vector<double>.One - y);
        y = x2 * SinDenom[14] * (Vector<double>.One - y);
        y = x2 * SinDenom[13] * (Vector<double>.One - y);
        y = x2 * SinDenom[12] * (Vector<double>.One - y);
        y = x2 * SinDenom[11] * (Vector<double>.One - y);
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_17()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_17(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_17(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[17];
        y = x2 * SinDenom[16] * (Vector<double>.One - y);
        y = x2 * SinDenom[15] * (Vector<double>.One - y);
        y = x2 * SinDenom[14] * (Vector<double>.One - y);
        y = x2 * SinDenom[13] * (Vector<double>.One - y);
        y = x2 * SinDenom[12] * (Vector<double>.One - y);
        y = x2 * SinDenom[11] * (Vector<double>.One - y);
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_18()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_18(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_18(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[18];
        y = x2 * SinDenom[17] * (Vector<double>.One - y);
        y = x2 * SinDenom[16] * (Vector<double>.One - y);
        y = x2 * SinDenom[15] * (Vector<double>.One - y);
        y = x2 * SinDenom[14] * (Vector<double>.One - y);
        y = x2 * SinDenom[13] * (Vector<double>.One - y);
        y = x2 * SinDenom[12] * (Vector<double>.One - y);
        y = x2 * SinDenom[11] * (Vector<double>.One - y);
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    
    [Benchmark]
    public double[] Use_Sin_19()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Sin_19(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Sin_19(in Vector<double> x)
    {
        var x2 = x * x;
        var y = SinDenom[19];
        y = x2 * SinDenom[18] * (Vector<double>.One - y);
        y = x2 * SinDenom[17] * (Vector<double>.One - y);
        y = x2 * SinDenom[16] * (Vector<double>.One - y);
        y = x2 * SinDenom[15] * (Vector<double>.One - y);
        y = x2 * SinDenom[14] * (Vector<double>.One - y);
        y = x2 * SinDenom[13] * (Vector<double>.One - y);
        y = x2 * SinDenom[12] * (Vector<double>.One - y);
        y = x2 * SinDenom[11] * (Vector<double>.One - y);
        y = x2 * SinDenom[10] * (Vector<double>.One - y);
        y = x2 * SinDenom[9] * (Vector<double>.One - y);
        y = x2 * SinDenom[8] * (Vector<double>.One - y);
        y = x2 * SinDenom[7] * (Vector<double>.One - y);
        y = x2 * SinDenom[6] * (Vector<double>.One - y);
        y = x2 * SinDenom[5] * (Vector<double>.One - y);
        y = x2 * SinDenom[4] * (Vector<double>.One - y);
        y = x2 * SinDenom[3] * (Vector<double>.One - y);
        y = x2 * SinDenom[2] * (Vector<double>.One - y);
        y = x2 * SinDenom[1] * (Vector<double>.One - y);
        y = x2 * SinDenom[0] * (Vector<double>.One - y);
        return x * (Vector<double>.One - y);
    }
    

    [Benchmark]
    public double[] Use_Cos_1()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_1(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_1(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[1];
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_2()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_2(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_2(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[2];
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_3()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_3(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_3(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[3];
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_4()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_4(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_4(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[4];
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_5()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_5(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_5(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[5];
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_6()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_6(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_6(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[6];
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_7()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_7(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_7(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[7];
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_8()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_8(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_8(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[8];
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_9()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_9(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_9(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[9];
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_10()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_10(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_10(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[10];
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_11()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_11(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_11(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[11];
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_12()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_12(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_12(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[12];
        y = x2 * CosDenom[11] * (Vector<double>.One - y);
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_13()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_13(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_13(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[13];
        y = x2 * CosDenom[12] * (Vector<double>.One - y);
        y = x2 * CosDenom[11] * (Vector<double>.One - y);
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_14()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_14(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_14(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[14];
        y = x2 * CosDenom[13] * (Vector<double>.One - y);
        y = x2 * CosDenom[12] * (Vector<double>.One - y);
        y = x2 * CosDenom[11] * (Vector<double>.One - y);
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_15()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_15(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_15(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[15];
        y = x2 * CosDenom[14] * (Vector<double>.One - y);
        y = x2 * CosDenom[13] * (Vector<double>.One - y);
        y = x2 * CosDenom[12] * (Vector<double>.One - y);
        y = x2 * CosDenom[11] * (Vector<double>.One - y);
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_16()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_16(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_16(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[16];
        y = x2 * CosDenom[15] * (Vector<double>.One - y);
        y = x2 * CosDenom[14] * (Vector<double>.One - y);
        y = x2 * CosDenom[13] * (Vector<double>.One - y);
        y = x2 * CosDenom[12] * (Vector<double>.One - y);
        y = x2 * CosDenom[11] * (Vector<double>.One - y);
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_17()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_17(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_17(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[17];
        y = x2 * CosDenom[16] * (Vector<double>.One - y);
        y = x2 * CosDenom[15] * (Vector<double>.One - y);
        y = x2 * CosDenom[14] * (Vector<double>.One - y);
        y = x2 * CosDenom[13] * (Vector<double>.One - y);
        y = x2 * CosDenom[12] * (Vector<double>.One - y);
        y = x2 * CosDenom[11] * (Vector<double>.One - y);
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_18()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_18(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_18(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[18];
        y = x2 * CosDenom[17] * (Vector<double>.One - y);
        y = x2 * CosDenom[16] * (Vector<double>.One - y);
        y = x2 * CosDenom[15] * (Vector<double>.One - y);
        y = x2 * CosDenom[14] * (Vector<double>.One - y);
        y = x2 * CosDenom[13] * (Vector<double>.One - y);
        y = x2 * CosDenom[12] * (Vector<double>.One - y);
        y = x2 * CosDenom[11] * (Vector<double>.One - y);
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }



    [Benchmark]
    public double[] Use_Cos_19()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Cos_19(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Cos_19(in Vector<double> x)
    {
        var x2 = x * x;
        var y = CosDenom[19];
        y = x2 * CosDenom[18] * (Vector<double>.One - y);
        y = x2 * CosDenom[17] * (Vector<double>.One - y);
        y = x2 * CosDenom[16] * (Vector<double>.One - y);
        y = x2 * CosDenom[15] * (Vector<double>.One - y);
        y = x2 * CosDenom[14] * (Vector<double>.One - y);
        y = x2 * CosDenom[13] * (Vector<double>.One - y);
        y = x2 * CosDenom[12] * (Vector<double>.One - y);
        y = x2 * CosDenom[11] * (Vector<double>.One - y);
        y = x2 * CosDenom[10] * (Vector<double>.One - y);
        y = x2 * CosDenom[9] * (Vector<double>.One - y);
        y = x2 * CosDenom[8] * (Vector<double>.One - y);
        y = x2 * CosDenom[7] * (Vector<double>.One - y);
        y = x2 * CosDenom[6] * (Vector<double>.One - y);
        y = x2 * CosDenom[5] * (Vector<double>.One - y);
        y = x2 * CosDenom[4] * (Vector<double>.One - y);
        y = x2 * CosDenom[3] * (Vector<double>.One - y);
        y = x2 * CosDenom[2] * (Vector<double>.One - y);
        y = x2 * CosDenom[1] * (Vector<double>.One - y);
        y = x2 * CosDenom[0] * (Vector<double>.One - y);
        return Vector<double>.One - y;
    }


}