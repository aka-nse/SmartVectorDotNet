// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using BenchmarkDotNet.Attributes;

namespace SmartVectorBenchmarks;

public partial class AtanBenchmarkContext
{
    public IReadOnlyDictionary<string, double> EvaluateErrors()
    {
        var retval = new Dictionary<string, double>();
        var expEmulated = Use_Atan_Emulated();
        retval["Atan_2"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_2());
        retval["Atan_3"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_3());
        retval["Atan_4"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_4());
        retval["Atan_5"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_5());
        retval["Atan_6"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_6());
        retval["Atan_7"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_7());
        retval["Atan_8"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_8());
        retval["Atan_9"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_9());
        retval["Atan_10"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_10());
        retval["Atan_11"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_11());
        retval["Atan_12"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_12());
        retval["Atan_13"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_13());
        retval["Atan_14"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_14());
        retval["Atan_15"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_15());
        retval["Atan_16"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_16());
        retval["Atan_17"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_17());
        retval["Atan_18"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_18());
        retval["Atan_19"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Atan_19());
        return retval;
    }


    [Benchmark]
    public double[] Use_Atan_2()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_2(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_2(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                ))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_3()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_3(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_3(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                )))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_4()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_4(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_4(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                ))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_5()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_5(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_5(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                )))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_6()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_6(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_6(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                ))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_7()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_7(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_7(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                )))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_8()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_8(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_8(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                ))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_9()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_9(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_9(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                )))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_10()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_10(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_10(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                ))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_11()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_11(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_11(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                )))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_12()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_12(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_12(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                + x2 * (_AtanCoeffs[11]
                ))))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_13()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_13(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_13(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                + x2 * (_AtanCoeffs[11]
                + x2 * (_AtanCoeffs[12]
                )))))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_14()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_14(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_14(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                + x2 * (_AtanCoeffs[11]
                + x2 * (_AtanCoeffs[12]
                + x2 * (_AtanCoeffs[13]
                ))))))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_15()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_15(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_15(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                + x2 * (_AtanCoeffs[11]
                + x2 * (_AtanCoeffs[12]
                + x2 * (_AtanCoeffs[13]
                + x2 * (_AtanCoeffs[14]
                )))))))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_16()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_16(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_16(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                + x2 * (_AtanCoeffs[11]
                + x2 * (_AtanCoeffs[12]
                + x2 * (_AtanCoeffs[13]
                + x2 * (_AtanCoeffs[14]
                + x2 * (_AtanCoeffs[15]
                ))))))))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_17()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_17(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_17(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                + x2 * (_AtanCoeffs[11]
                + x2 * (_AtanCoeffs[12]
                + x2 * (_AtanCoeffs[13]
                + x2 * (_AtanCoeffs[14]
                + x2 * (_AtanCoeffs[15]
                + x2 * (_AtanCoeffs[16]
                )))))))))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_18()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_18(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_18(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                + x2 * (_AtanCoeffs[11]
                + x2 * (_AtanCoeffs[12]
                + x2 * (_AtanCoeffs[13]
                + x2 * (_AtanCoeffs[14]
                + x2 * (_AtanCoeffs[15]
                + x2 * (_AtanCoeffs[16]
                + x2 * (_AtanCoeffs[17]
                ))))))))))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }


    [Benchmark]
    public double[] Use_Atan_19()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Atan_19(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Atan_19(in Vector<double> x)
    {
        static Vector<double> core(Vector<double> x)
        {
            var condition = Vector.LessThan(x, _CoreXReflectThreshold);
            x = Vector.ConditionalSelect(
                condition,
                x,
                (x - Vector<double>.One) / (x + Vector<double>.One)
            );
            var offset = Vector.ConditionalSelect(
                condition,
                Vector<double>.Zero,
                _CoreOffset
            );
            var x2 = x * x;
            return x * (Vector<double>.One
                + x2 * (_AtanCoeffs[0]
                + x2 * (_AtanCoeffs[1]
                + x2 * (_AtanCoeffs[2]
                + x2 * (_AtanCoeffs[3]
                + x2 * (_AtanCoeffs[4]
                + x2 * (_AtanCoeffs[5]
                + x2 * (_AtanCoeffs[6]
                + x2 * (_AtanCoeffs[7]
                + x2 * (_AtanCoeffs[8]
                + x2 * (_AtanCoeffs[9]
                + x2 * (_AtanCoeffs[10]
                + x2 * (_AtanCoeffs[11]
                + x2 * (_AtanCoeffs[12]
                + x2 * (_AtanCoeffs[13]
                + x2 * (_AtanCoeffs[14]
                + x2 * (_AtanCoeffs[15]
                + x2 * (_AtanCoeffs[16]
                + x2 * (_AtanCoeffs[17]
                + x2 * (_AtanCoeffs[18]
                )))))))))))))))))))) + offset;
        }

        var sign = SignFast(x);
        var xx = sign * x;
        var xxx = Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            xx,
            Vector<double>.One / xx
        );
        var y = core(xxx);
        return sign * Vector.ConditionalSelect(
            Vector.LessThan(xx, Vector<double>.One),
            y,
            _WrapperOffset - y
        );
    }

}