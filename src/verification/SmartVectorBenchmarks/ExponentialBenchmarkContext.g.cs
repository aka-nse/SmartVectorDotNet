// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using BenchmarkDotNet.Attributes;

namespace SmartVectorBenchmarks;

public partial class ExponentialBenchmarkContext
{
    public IReadOnlyDictionary<string, double> EvaluateErrors()
    {
        var retval = new Dictionary<string, double>();
        var expEmulated = Use_Exp_Emulated();
        retval["Exp_1"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_1());
        retval["Exp_2"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_2());
        retval["Exp_3"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_3());
        retval["Exp_4"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_4());
        retval["Exp_5"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_5());
        retval["Exp_6"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_6());
        retval["Exp_7"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_7());
        retval["Exp_8"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_8());
        retval["Exp_9"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_9());
        retval["Exp_10"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_10());
        retval["Exp_11"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_11());
        retval["Exp_12"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_12());
        retval["Exp_13"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_13());
        retval["Exp_14"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_14());
        retval["Exp_15"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_15());
        retval["Exp_16"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_16());
        retval["Exp_17"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_17());
        retval["Exp_18"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_18());
        retval["Exp_19"] = BenchmarkHelper.CalculateErrorRelative(expEmulated, Use_Exp_19());
        return retval;
    }


    [Benchmark]
    public double[] Use_Exp_1()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_1(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_1(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_2()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_2(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_2(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_3()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_3(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_3(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_4()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_4(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_4(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_5()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_5(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_5(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_6()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_6(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_6(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_7()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_7(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_7(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_8()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_8(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_8(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_9()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_9(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_9(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_10()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_10(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_10(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_11()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_11(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_11(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_12()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_12(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_12(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[11]) * (Vector<double>.One + z);
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_13()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_13(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_13(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[12]) * (Vector<double>.One + z);
        z = (b * ExpDenom[11]) * (Vector<double>.One + z);
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_14()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_14(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_14(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[13]) * (Vector<double>.One + z);
        z = (b * ExpDenom[12]) * (Vector<double>.One + z);
        z = (b * ExpDenom[11]) * (Vector<double>.One + z);
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_15()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_15(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_15(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[14]) * (Vector<double>.One + z);
        z = (b * ExpDenom[13]) * (Vector<double>.One + z);
        z = (b * ExpDenom[12]) * (Vector<double>.One + z);
        z = (b * ExpDenom[11]) * (Vector<double>.One + z);
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_16()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_16(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_16(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[15]) * (Vector<double>.One + z);
        z = (b * ExpDenom[14]) * (Vector<double>.One + z);
        z = (b * ExpDenom[13]) * (Vector<double>.One + z);
        z = (b * ExpDenom[12]) * (Vector<double>.One + z);
        z = (b * ExpDenom[11]) * (Vector<double>.One + z);
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_17()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_17(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_17(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[16]) * (Vector<double>.One + z);
        z = (b * ExpDenom[15]) * (Vector<double>.One + z);
        z = (b * ExpDenom[14]) * (Vector<double>.One + z);
        z = (b * ExpDenom[13]) * (Vector<double>.One + z);
        z = (b * ExpDenom[12]) * (Vector<double>.One + z);
        z = (b * ExpDenom[11]) * (Vector<double>.One + z);
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_18()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_18(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_18(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[17]) * (Vector<double>.One + z);
        z = (b * ExpDenom[16]) * (Vector<double>.One + z);
        z = (b * ExpDenom[15]) * (Vector<double>.One + z);
        z = (b * ExpDenom[14]) * (Vector<double>.One + z);
        z = (b * ExpDenom[13]) * (Vector<double>.One + z);
        z = (b * ExpDenom[12]) * (Vector<double>.One + z);
        z = (b * ExpDenom[11]) * (Vector<double>.One + z);
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }


    [Benchmark]
    public double[] Use_Exp_19()
    {
        var retval = new double[BenchmarkSize];
        var retvalAsVector = MemoryMarshal.Cast<double, Vector<double>>(retval);
        var xAsVector = XAsVector;
        for(var i = 0; i < xAsVector.Length; ++i)
        {
            retvalAsVector[i] = Exp_19(xAsVector[i]);
        }
        return retval;
    }

    private static Vector<double> Exp_19(in Vector<double> x)
    {
        var y = x * Log_2_E;
        var n = Round(y);
        var a = y - n;
        var b = a * Log_E_2;
        var z = Vector<double>.Zero;
        z = (b * ExpDenom[18]) * (Vector<double>.One + z);
        z = (b * ExpDenom[17]) * (Vector<double>.One + z);
        z = (b * ExpDenom[16]) * (Vector<double>.One + z);
        z = (b * ExpDenom[15]) * (Vector<double>.One + z);
        z = (b * ExpDenom[14]) * (Vector<double>.One + z);
        z = (b * ExpDenom[13]) * (Vector<double>.One + z);
        z = (b * ExpDenom[12]) * (Vector<double>.One + z);
        z = (b * ExpDenom[11]) * (Vector<double>.One + z);
        z = (b * ExpDenom[10]) * (Vector<double>.One + z);
        z = (b * ExpDenom[9]) * (Vector<double>.One + z);
        z = (b * ExpDenom[8]) * (Vector<double>.One + z);
        z = (b * ExpDenom[7]) * (Vector<double>.One + z);
        z = (b * ExpDenom[6]) * (Vector<double>.One + z);
        z = (b * ExpDenom[5]) * (Vector<double>.One + z);
        z = (b * ExpDenom[4]) * (Vector<double>.One + z);
        z = (b * ExpDenom[3]) * (Vector<double>.One + z);
        z = (b * ExpDenom[2]) * (Vector<double>.One + z);
        z = (b * ExpDenom[1]) * (Vector<double>.One + z);
        z = (b * ExpDenom[0]) * (Vector<double>.One + z);
        z = z + Vector<double>.One;
        return Scale(n, z);
    }

}